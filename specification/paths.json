{
  "/addon": {
    "delete": {
      "description": "",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "addon"
      ]
    },
    "parameters": [],
    "put": {
      "description": "",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "addon"
      ]
    }
  },
  "/addon/linkers": {
    "get": {
      "description": "",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "addon"
      ]
    },
    "parameters": []
  },
  "/addon/linkers/{linker_key}": {
    "get": {
      "description": "",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "addon"
      ]
    },
    "parameters": [
      {
        "in": "path",
        "name": "linker_key",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/addon/linkers/{linker_key}/values": {
    "delete": {
      "description": "",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "addon"
      ]
    },
    "get": {
      "description": "",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "addon"
      ]
    },
    "parameters": [
      {
        "in": "path",
        "name": "linker_key",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "addon"
      ]
    },
    "put": {
      "description": "",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "addon"
      ]
    }
  },
  "/addon/linkers/{linker_key}/values/": {
    "delete": {
      "description": "",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "addon"
      ]
    },
    "get": {
      "description": "",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "addon"
      ]
    },
    "parameters": [
      {
        "in": "path",
        "name": "linker_key",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/addon/users/{target_user}/events/{event_key}": {
    "parameters": [
      {
        "description": "The account the app is installed in.\n\nThis can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "target_user",
        "required": true,
        "type": "string"
      },
      {
        "description": "The key of the event, which corresponds to an event\ndefined in the connect app descriptor.\n",
        "in": "path",
        "name": "event_key",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "POST a new custom event.\n\nThe data within the event body will be hydrated by Bitbucket. For example, the following event\nsubmission would result in subscribers for the event receiving the full repository object\ncorresponding to the UUID.\n\n```\n$ curl -X POST -H \"Content-Type: application/json\" -d '{\n    \"mynumdata\": \"12345\",\n    \"repository\": {\n        \"type\": \"repository\",\n        \"uuid\": \"{be95aa1f-c0b2-47f6-99d1-bf5d3a0f850f}\"\n}}' https://api.bitbucket.org/2.0/addon/users/myuser/events/com.example.app%3Amyevent\n```\n\nUse the optional `fields` property of the custom event Connect\nmodule where the event is defined to add additional\nfields to the expanded payload sent to listeners.\n\nFor example, the `customEvents` module in the app descriptor for the previous example would look like this:\n\n```\n'modules': {\n    'customEvents': {\n        'com.example.app:myevent': {\n            'schema': {\n                'properties': {\n                    'mynumdata': {'type': 'number'},\n                    'repository': {'$ref': '#/definitions/repository'}\n                }\n            },\n            'fields': ['repository.owner']\n        }\n    }\n}\n```\n\nBy specifying fields as above, the repository owner\nwill also be sent to subscribers of the event.",
      "parameters": [],
      "responses": {
        "204": {
          "description": "Event successfully submitted"
        },
        "404": {
          "description": "Connect app not installed or event does not exist"
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "addon"
      ]
    }
  },
  "/hook_events": {
    "get": {
      "description": "Returns the webhook resource or subject types on which webhooks can\nbe registered.\n\nEach resource/subject type contains an `events` link that returns the\npaginated list of specific events each individual subject type can\nemit.\n\nThis endpoint is publicly accessible and does not require\nauthentication or scopes.\n\nExample:\n\n```\n$ curl https://api.bitbucket.org/2.0/hook_events\n\n{\n    \"repository\": {\n        \"links\": {\n            \"events\": {\n                \"href\": \"https://api.bitbucket.org/2.0/hook_events/repository\"\n            }\n        }\n    },\n    \"team\": {\n        \"links\": {\n            \"events\": {\n                \"href\": \"https://api.bitbucket.org/2.0/hook_events/team\"\n            }\n        }\n    },\n    \"user\": {\n        \"links\": {\n            \"events\": {\n                \"href\": \"https://api.bitbucket.org/2.0/hook_events/user\"\n            }\n        }\n    }\n}\n```",
      "parameters": [],
      "responses": {
        "200": {
          "description": "A mapping of resource/subject types pointing to their individual event types.",
          "schema": {
            "$ref": "#/definitions/subject_types"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "webhooks"
      ]
    },
    "parameters": []
  },
  "/hook_events/{subject_type}": {
    "get": {
      "description": "Returns a paginated list of all valid webhook events for the\nspecified entity.\n\nThis is public data that does not require any scopes or authentication.\n\nExample:\n\nNOTE: The following example is a truncated response object for the `team` `subject_type`.\nWe return the same structure for the other `subject_type` objects.\n\n```\n$ curl https://api.bitbucket.org/2.0/hook_events/team\n{\n    \"page\": 1,\n    \"pagelen\": 30,\n    \"size\": 21,\n    \"values\": [\n        {\n            \"category\": \"Repository\",\n            \"description\": \"Whenever a repository push occurs\",\n            \"event\": \"repo:push\",\n            \"label\": \"Push\"\n        },\n        {\n            \"category\": \"Repository\",\n            \"description\": \"Whenever a repository fork occurs\",\n            \"event\": \"repo:fork\",\n            \"label\": \"Fork\"\n        },\n        ...\n        {\n            \"category\": \"Repository\",\n            \"description\": \"Whenever a repository import occurs\",\n            \"event\": \"repo:imported\",\n            \"label\": \"Import\"\n        }\n    ]\n}\n```",
      "parameters": [
        {
          "description": "A resource or subject type.",
          "enum": [
            "workspace",
            "user",
            "repository",
            "team"
          ],
          "in": "path",
          "name": "subject_type",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of webhook types available to subscribe on.",
          "schema": {
            "$ref": "#/definitions/paginated_hook_events"
          }
        },
        "404": {
          "description": "If an invalid `{subject_type}` value was specified.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "webhooks"
      ]
    },
    "parameters": [
      {
        "in": "path",
        "name": "subject_type",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/pullrequests/{selected_user}": {
    "get": {
      "description": "Returns all pull requests authored by the specified user.\n\nBy default only open pull requests are returned. This can be controlled\nusing the `state` query parameter. To retrieve pull requests that are\nin one of multiple states, repeat the `state` parameter for each\nindividual state.\n\nThis endpoint also supports filtering and sorting of the results. See\n[filtering and sorting](../../../../meta/filtering) for more details.",
      "parameters": [
        {
          "description": "This can either be the username of the pull request author, the author's UUID\nsurrounded by curly-braces, for example: `{account UUID}`, or the author's Atlassian ID.\n",
          "in": "path",
          "name": "selected_user",
          "required": true,
          "type": "string"
        },
        {
          "description": "Only return pull requests that are in this state. This parameter can be repeated.",
          "enum": [
            "MERGED",
            "SUPERSEDED",
            "OPEN",
            "DECLINED"
          ],
          "in": "query",
          "name": "state",
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "All pull requests authored by the specified user.",
          "schema": {
            "$ref": "#/definitions/paginated_pullrequests"
          }
        },
        "404": {
          "description": "If the specified user does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "in": "path",
        "name": "selected_user",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories": {
    "get": {
      "description": "Returns a paginated list of all public repositories.\n\nThis endpoint also supports filtering and sorting of the results. See\n[filtering and sorting](../meta/filtering) for more details.",
      "parameters": [
        {
          "description": "Filter the results to include only repositories create on or\nafter this [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)\n timestamp. Example: `YYYY-MM-DDTHH:mm:ss.sssZ`",
          "in": "query",
          "name": "after",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "All public repositories.",
          "schema": {
            "$ref": "#/definitions/paginated_repositories"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories"
      ]
    },
    "parameters": []
  },
  "/repositories/{username}": {
    "get": {
      "description": "Returns a paginated list of all repositories owned by the specified\naccount or UUID.\n\nThe result can be narrowed down based on the authenticated user's role.\n\nE.g. with `?role=contributor`, only those repositories that the\nauthenticated user has write access to are returned (this includes any\nrepo the user is an admin on, as that implies write access).\n\nThis endpoint also supports filtering and sorting of the results. See\n[filtering and sorting](../../meta/filtering) for more details.",
      "parameters": [
        {
          "description": "\nFilters the result based on the authenticated user's role on each repository.\n\n* **member**: returns repositories to which the user has explicit read access\n* **contributor**: returns repositories to which the user has explicit write access\n* **admin**: returns repositories to which the user has explicit administrator access\n* **owner**: returns all repositories owned by the current user\n",
          "enum": [
            "admin",
            "contributor",
            "member",
            "owner"
          ],
          "in": "query",
          "name": "role",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The repositories owned by the specified account.",
          "schema": {
            "$ref": "#/definitions/paginated_repositories"
          }
        },
        "404": {
          "description": "If the specified account does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "410": {
          "description": "If the specified account marked as spam.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}": {
    "delete": {
      "description": "Deletes the repository. This is an irreversible operation.\n\nThis does not affect its forks.",
      "parameters": [
        {
          "description": "If a repository has been moved to a new location, use this parameter to\nshow users a friendly message in the Bitbucket UI that the repository\nhas moved to a new location. However, a GET to this endpoint will still\nreturn a 404.\n",
          "in": "query",
          "name": "redirect_to",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "Indicates successful deletion."
        },
        "403": {
          "description": "If the caller either does not have admin access to the repository, or the repository is set to read-only.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:delete"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories"
      ]
    },
    "get": {
      "description": "Returns the object describing this repository.",
      "parameters": [],
      "produces": [
        "application/json"
      ],
      "responses": {
        "200": {
          "description": "The repository object.",
          "examples": {
            "application/json": {
              "created_on": "2018-06-20T23:17:33.616037+00:00",
              "description": "A repository for my bits and bobs",
              "fork_policy": "allow_forks",
              "full_name": "example-username/bits_and_bobs",
              "has_issues": false,
              "has_wiki": false,
              "is_private": true,
              "language": "python",
              "links": {
                "avatar": {
                  "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                },
                "branches": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/refs/branches"
                },
                "clone": [
                  {
                    "href": "https://bitbucket.org/example-username/bits_and_bobs.git",
                    "name": "https"
                  },
                  {
                    "href": "git@bitbucket.org:example-username/bits_and_bobs.git",
                    "name": "ssh"
                  }
                ],
                "commits": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commits"
                },
                "downloads": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/downloads"
                },
                "forks": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/forks"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/bits_and_bobs"
                },
                "pullrequests": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                },
                "source": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/src"
                },
                "tags": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/refs/tags"
                },
                "watchers": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/watchers"
                }
              },
              "mainbranch": {
                "name": "master",
                "type": "branch"
              },
              "name": "bits_and_bobs",
              "owner": {
                "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
                "display_name": "Example Username",
                "links": {
                  "avatar": {
                    "href": "https://bitbucket.org/account/example-username/avatar/"
                  },
                  "html": {
                    "href": "https://bitbucket.org/example-username/"
                  },
                  "self": {
                    "href": "https://api.bitbucket.org/2.0/users/example-username"
                  }
                },
                "nickname": "example-username",
                "type": "user",
                "username": "example-username",
                "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
              },
              "scm": "git",
              "size": 33348,
              "slug": "bits_and_bobs",
              "type": "repository",
              "updated_on": "2018-06-20T23:17:33.616037+00:00",
              "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}",
              "website": "www.example.com"
            }
          },
          "schema": {
            "$ref": "#/definitions/repository"
          }
        },
        "403": {
          "description": "If the repository is private and the authenticated user does not have access to it.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If no repository exists at this location.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new repository.\n\nNote: In order to set the project for the newly created repository,\npass in either the project key or the project UUID as part of the\nrequest body as shown in the examples below:\n\n```\n$ curl -X POST -H \"Content-Type: application/json\" -d '{\n    \"scm\": \"git\",\n    \"project\": {\n        \"key\": \"MARS\"\n    }\n}' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding\n```\n\nor\n\n```\n$ curl -X POST -H \"Content-Type: application/json\" -d '{\n    \"scm\": \"git\",\n    \"project\": {\n        \"key\": \"{ba516952-992a-4c2d-acbd-17d502922f96}\"\n    }\n}' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding\n```\n\nThe project must only be assigned for repositories belonging to a team.\nIf the repository owner is a team and the project is not provided, the\nrepository is automatically assigned to the oldest project in the team.\n\nNote: In the examples above, the username `teamsinspace`,\nand/or the repository name `hablanding` can be replaced by UUIDs.",
      "parameters": [
        {
          "description": "The repository that is to be created. Note that most object elements are optional. Elements \"owner\" and \"full_name\" are ignored as the URL implies them.",
          "in": "body",
          "name": "_body",
          "required": false,
          "schema": {
            "$ref": "#/definitions/repository"
          }
        }
      ],
      "produces": [
        "application/json"
      ],
      "responses": {
        "200": {
          "description": "The newly created repository.",
          "examples": {
            "application/json": {
              "created_on": "2018-06-20T23:17:33.616037+00:00",
              "description": "A repository for my bits and bobs",
              "fork_policy": "allow_forks",
              "full_name": "example-username/bits_and_bobs",
              "has_issues": false,
              "has_wiki": false,
              "is_private": true,
              "language": "python",
              "links": {
                "avatar": {
                  "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                },
                "branches": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/refs/branches"
                },
                "clone": [
                  {
                    "href": "https://bitbucket.org/example-username/bits_and_bobs.git",
                    "name": "https"
                  },
                  {
                    "href": "git@bitbucket.org:example-username/bits_and_bobs.git",
                    "name": "ssh"
                  }
                ],
                "commits": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commits"
                },
                "downloads": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/downloads"
                },
                "forks": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/forks"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/bits_and_bobs"
                },
                "pullrequests": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                },
                "source": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/src"
                },
                "tags": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/refs/tags"
                },
                "watchers": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/watchers"
                }
              },
              "mainbranch": {
                "name": "master",
                "type": "branch"
              },
              "name": "bits_and_bobs",
              "owner": {
                "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
                "display_name": "Example Username",
                "links": {
                  "avatar": {
                    "href": "https://bitbucket.org/account/example-username/avatar/"
                  },
                  "html": {
                    "href": "https://bitbucket.org/example-username/"
                  },
                  "self": {
                    "href": "https://api.bitbucket.org/2.0/users/example-username"
                  }
                },
                "nickname": "example-username",
                "type": "user",
                "username": "example-username",
                "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
              },
              "scm": "git",
              "size": 33348,
              "slug": "bits_and_bobs",
              "type": "repository",
              "updated_on": "2018-06-20T23:17:33.616037+00:00",
              "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}",
              "website": "www.example.com"
            }
          },
          "schema": {
            "$ref": "#/definitions/repository"
          }
        },
        "400": {
          "description": "If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "401": {
          "description": "If the request was not authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories"
      ]
    },
    "put": {
      "description": "Since this endpoint can be used to both update and to create a\nrepository, the request body depends on the intent.\n\n### Creation\n\nSee the POST documentation for the repository endpoint for an example\nof the request body.\n\n### Update\n\nNote: Changing the `name` of the repository will cause the location to\nbe changed. This is because the URL of the repo is derived from the\nname (a process called slugification). In such a scenario, it is\npossible for the request to fail if the newly created slug conflicts\nwith an existing repository's slug. But if there is no conflict,\nthe new location will be returned in the `Location` header of the\nresponse.",
      "parameters": [
        {
          "description": "The repository that is to be updated.\n\nNote that the elements \"owner\" and \"full_name\" are ignored since the\nURL implies them.\n",
          "in": "body",
          "name": "_body",
          "required": false,
          "schema": {
            "$ref": "#/definitions/repository"
          }
        }
      ],
      "produces": [
        "application/json"
      ],
      "responses": {
        "200": {
          "description": "The existing repository has been updated",
          "examples": {
            "application/json": {
              "created_on": "2018-06-20T23:17:33.616037+00:00",
              "description": "A repository for my bits and bobs",
              "fork_policy": "allow_forks",
              "full_name": "example-username/bits_and_bobs",
              "has_issues": false,
              "has_wiki": false,
              "is_private": true,
              "language": "python",
              "links": {
                "avatar": {
                  "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                },
                "branches": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/refs/branches"
                },
                "clone": [
                  {
                    "href": "https://bitbucket.org/example-username/bits_and_bobs.git",
                    "name": "https"
                  },
                  {
                    "href": "git@bitbucket.org:example-username/bits_and_bobs.git",
                    "name": "ssh"
                  }
                ],
                "commits": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commits"
                },
                "downloads": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/downloads"
                },
                "forks": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/forks"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/bits_and_bobs"
                },
                "pullrequests": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                },
                "source": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/src"
                },
                "tags": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/refs/tags"
                },
                "watchers": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/watchers"
                }
              },
              "mainbranch": {
                "name": "master",
                "type": "branch"
              },
              "name": "bits_and_bobs",
              "owner": {
                "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
                "display_name": "Example Username",
                "links": {
                  "avatar": {
                    "href": "https://bitbucket.org/account/example-username/avatar/"
                  },
                  "html": {
                    "href": "https://bitbucket.org/example-username/"
                  },
                  "self": {
                    "href": "https://api.bitbucket.org/2.0/users/example-username"
                  }
                },
                "nickname": "example-username",
                "type": "user",
                "username": "example-username",
                "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
              },
              "scm": "git",
              "size": 33348,
              "slug": "bits_and_bobs",
              "type": "repository",
              "updated_on": "2018-06-20T23:17:33.616037+00:00",
              "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}",
              "website": "www.example.com"
            }
          },
          "headers": {
            "Location": {
              "description": "The location of the repository. This header is only\nprovided when the repository's name is changed.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/repository"
          }
        },
        "201": {
          "description": "A new repository has been created",
          "examples": {
            "application/json": {
              "created_on": "2018-06-20T23:17:33.616037+00:00",
              "description": "A repository for my bits and bobs",
              "fork_policy": "allow_forks",
              "full_name": "example-username/bits_and_bobs",
              "has_issues": false,
              "has_wiki": false,
              "is_private": true,
              "language": "python",
              "links": {
                "avatar": {
                  "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                },
                "branches": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/refs/branches"
                },
                "clone": [
                  {
                    "href": "https://bitbucket.org/example-username/bits_and_bobs.git",
                    "name": "https"
                  },
                  {
                    "href": "git@bitbucket.org:example-username/bits_and_bobs.git",
                    "name": "ssh"
                  }
                ],
                "commits": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commits"
                },
                "downloads": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/downloads"
                },
                "forks": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/forks"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/bits_and_bobs"
                },
                "pullrequests": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                },
                "source": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/src"
                },
                "tags": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/refs/tags"
                },
                "watchers": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/watchers"
                }
              },
              "mainbranch": {
                "name": "master",
                "type": "branch"
              },
              "name": "bits_and_bobs",
              "owner": {
                "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
                "display_name": "Example Username",
                "links": {
                  "avatar": {
                    "href": "https://bitbucket.org/account/example-username/avatar/"
                  },
                  "html": {
                    "href": "https://bitbucket.org/example-username/"
                  },
                  "self": {
                    "href": "https://api.bitbucket.org/2.0/users/example-username"
                  }
                },
                "nickname": "example-username",
                "type": "user",
                "username": "example-username",
                "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
              },
              "scm": "git",
              "size": 33348,
              "slug": "bits_and_bobs",
              "type": "repository",
              "updated_on": "2018-06-20T23:17:33.616037+00:00",
              "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}",
              "website": "www.example.com"
            }
          },
          "headers": {
            "Location": {
              "description": "The location of the newly created repository",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/repository"
          }
        },
        "400": {
          "description": "If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "401": {
          "description": "If the request was not authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/branch-restrictions": {
    "get": {
      "description": "Returns a paginated list of all branch restrictions on the\nrepository.",
      "parameters": [
        {
          "description": "Branch restrictions of this type",
          "in": "query",
          "name": "kind",
          "required": false,
          "type": "string"
        },
        {
          "description": "Branch restrictions applied to branches of this pattern",
          "in": "query",
          "name": "pattern",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of branch restrictions",
          "schema": {
            "$ref": "#/definitions/paginated_branchrestrictions"
          }
        },
        "401": {
          "description": "If the request was not authenticated",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If the authenticated user does not have admin access to the repository",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the repository does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "branchrestrictions"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new branch restriction rule for a repository.\n\n`kind` describes what will be restricted. Allowed values include:\n`push`, `force`, `delete` and `restrict_merges`.\n\nDifferent kinds of branch restrictions have different requirements:\n\n* `push` and `restrict_merges` require `users` and `groups` to be\n  specified. Empty lists are allowed, in which case permission is\n  denied for everybody.\n* `force` can not be specified in a Mercurial repository.\n\nThe restriction applies to all branches that match. There are\ntwo ways to match a branch. It is configured in `branch_match_kind`:\n\n1. `glob`: Matches a branch against the `pattern`. A `'*'` in\n   `pattern` will expand to match zero or more characters, and every\n   other character matches itself. For example, `'foo*'` will match\n   `'foo'` and `'foobar'`, but not `'barfoo'`. `'*'` will match all\n   branches.\n2. `branching_model`: Matches a branch against the repository's\n   branching model. The `branch_type` controls the type of branch\n   to match. Allowed values include: `production`, `development`,\n   `bugfix`, `release`, `feature` and `hotfix`.\n\nThe combination of `kind` and match must be unique. This means that\ntwo `glob` restrictions in a repository cannot have the same `kind` and\n`pattern`. Additionally, two `branching_model` restrictions in a\nrepository cannot have the same `kind` and `branch_type`.\n\n`users` and `groups` are lists of users and groups that are except from\nthe restriction. They can only be configured in `push` and\n`restrict_merges` restrictions. The `push` restriction stops a user\npushing to matching branches unless that user is in `users` or is a\nmember of a group in `groups`. The `restrict_merges` stops a user\nmerging pull requests to matching branches unless that user is in\n`users` or is a member of a group in `groups`. Adding new users or\ngroups to an existing restriction should be done via `PUT`.\n\nNote that branch restrictions with overlapping matchers is allowed,\nbut the resulting behavior may be surprising.",
      "parameters": [
        {
          "description": "The new rule",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/branchrestriction"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "A paginated list of branch restrictions",
          "schema": {
            "$ref": "#/definitions/branchrestriction"
          }
        },
        "401": {
          "description": "If the request was not authenticated",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If the authenticated user does not have admin access to the repository",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the repository does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "branchrestrictions"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/branch-restrictions/{id}": {
    "delete": {
      "description": "Deletes an existing branch restriction rule.",
      "parameters": [],
      "responses": {
        "204": {
          "description": ""
        },
        "401": {
          "description": "If the request was not authenticated",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If the authenticated user does not have admin access to the repository",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the repository or branch restriction id does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "branchrestrictions"
      ]
    },
    "get": {
      "description": "Returns a specific branch restriction rule.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The branch restriction rule",
          "schema": {
            "$ref": "#/definitions/branchrestriction"
          }
        },
        "401": {
          "description": "If the request was not authenticated",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If the authenticated user does not have admin access to the repository",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the repository or branch restriction id does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "branchrestrictions"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The restriction rule's id",
        "in": "path",
        "name": "id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Updates an existing branch restriction rule.\n\nFields not present in the request body are ignored.\n\nSee [`POST`](../branch-restrictions#post) for details.",
      "parameters": [
        {
          "description": "The new version of the existing rule",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/branchrestriction"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The updated branch restriction rule",
          "schema": {
            "$ref": "#/definitions/branchrestriction"
          }
        },
        "401": {
          "description": "If the request was not authenticated",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If the authenticated user does not have admin access to the repository",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the repository or branch restriction id does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "branchrestrictions"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/branching-model": {
    "get": {
      "description": "Return the branching model as applied to the repository. This view is\nread-only. The branching model settings can be changed using the\n[settings](branching-model/settings#get) API.\n\nThe returned object:\n\n1. Always has a `development` property. `development.branch` contains\n   the actual repository branch object that is considered to be the\n   `development` branch. `development.branch` will not be present\n   if it does not exist.\n2. Might have a `production` property. `production` will not\n   be present when `production` is disabled.\n   `production.branch` contains the actual branch object that is\n   considered to be the `production` branch. `production.branch` will\n   not be present if it does not exist.\n3. Always has a `branch_types` array which contains all enabled branch\n   types.\n\nExample body:\n\n```\n{\n  \"development\": {\n    \"name\": \"master\",\n    \"branch\": {\n      \"type\": \"branch\",\n      \"name\": \"master\",\n      \"target\": {\n        \"hash\": \"16dffcb0de1b22e249db6799532074cf32efe80f\"\n      }\n    },\n    \"use_mainbranch\": true\n  },\n  \"production\": {\n    \"name\": \"production\",\n    \"branch\": {\n      \"type\": \"branch\",\n      \"name\": \"production\",\n      \"target\": {\n        \"hash\": \"16dffcb0de1b22e249db6799532074cf32efe80f\"\n      }\n    },\n    \"use_mainbranch\": false\n  },\n  \"branch_types\": [\n    {\n      \"kind\": \"release\",\n      \"prefix\": \"release/\"\n    },\n    {\n      \"kind\": \"hotfix\",\n      \"prefix\": \"hotfix/\"\n    },\n    {\n      \"kind\": \"feature\",\n      \"prefix\": \"feature/\"\n    },\n    {\n      \"kind\": \"bugfix\",\n      \"prefix\": \"bugfix/\"\n    }\n  ],\n  \"type\": \"branching_model\",\n  \"links\": {\n    \"self\": {\n      \"href\": \"https://api.bitbucket.org/.../branching-model\"\n    }\n  }\n}\n```",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The branching model object",
          "schema": {
            "$ref": "#/definitions/branching_model"
          }
        },
        "401": {
          "description": "If the request was not authenticated",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If the authenticated user does not have read access to the repository",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the repository does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "branching_model"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/branching-model/settings": {
    "get": {
      "description": "Return the branching model configuration for a repository. The returned\nobject:\n\n1. Always has a `development` property for the development branch.\n2. Always a `production` property for the production branch. The\n   production branch can be disabled.\n3. The `branch_types` contains all the branch types.\n\nThis is the raw configuration for the branching model. A client\nwishing to see the branching model with its actual current branches may\nfind the [active model API](../branching-model#get) more useful.\n\nExample body:\n\n```\n{\n  \"development\": {\n    \"is_valid\": true,\n    \"name\": null,\n    \"use_mainbranch\": true\n  },\n  \"production\": {\n    \"is_valid\": true,\n    \"name\": \"production\",\n    \"use_mainbranch\": false,\n    \"enabled\": false\n  },\n  \"branch_types\": [\n    {\n      \"kind\": \"release\",\n      \"enabled\": true,\n      \"prefix\": \"release/\"\n    },\n    {\n      \"kind\": \"hotfix\",\n      \"enabled\": true,\n      \"prefix\": \"hotfix/\"\n    },\n    {\n      \"kind\": \"feature\",\n      \"enabled\": true,\n      \"prefix\": \"feature/\"\n    },\n    {\n      \"kind\": \"bugfix\",\n      \"enabled\": false,\n      \"prefix\": \"bugfix/\"\n    }\n  ],\n  \"type\": \"branching_model_settings\",\n  \"links\": {\n    \"self\": {\n      \"href\": \"https://api.bitbucket.org/.../branching-model/settings\"\n    }\n  }\n}\n```",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The branching model configuration",
          "schema": {
            "$ref": "#/definitions/branching_model_settings"
          }
        },
        "401": {
          "description": "If the request was not authenticated",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If the authenticated user does not have admin access to the repository",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the repository does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "branching_model"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Update the branching model configuration for a repository.\n\nThe `development` branch can be configured to a specific branch or to\ntrack the main branch. When set to a specific branch it must\ncurrently exist. Only the passed properties will be updated. The\nproperties not passed will be left unchanged. A request without a\n`development` property will leave the development branch unchanged.\n\nIt is possible for the `development` branch to be invalid. This\nhappens when it points at a specific branch that has been\ndeleted. This is indicated in the `is_valid` field for the branch. It is\nnot possible to update the settings for `development` if that\nwould leave the branch in an invalid state. Such a request will be\nrejected.\n\nThe `production` branch can be a specific branch, the main\nbranch or disabled. When set to a specific branch it must currently\nexist. The `enabled` property can be used to enable (`true`) or\ndisable (`false`) it. Only the passed properties will be updated. The\nproperties not passed will be left unchanged. A request without a\n`production` property will leave the production branch unchanged.\n\nIt is possible for the `production` branch to be invalid. This\nhappens when it points at a specific branch that has been\ndeleted. This is indicated in the `is_valid` field for the branch. A\nrequest that would leave `production` enabled and invalid will be\nrejected. It is possible to update `production` and make it invalid if\nit would also be left disabled.\n\nThe `branch_types` property contains the branch types to be updated.\nOnly the branch types passed will be updated. All updates will be\nrejected if it would leave the branching model in an invalid state.\nFor branch types this means that:\n\n1. The prefixes for all enabled branch types are valid. For example,\n   it is not possible to use '*' inside a Git prefix.\n2. A prefix of an enabled branch type must not be a prefix of another\n   enabled branch type. This is to ensure that a branch can be easily\n   classified by its prefix unambiguously.\n\nIt is possible to store an invalid prefix if that branch type would be\nleft disabled. Only the passed properties will be updated. The\nproperties not passed will be left unchanged. Each branch type must\nhave a `kind` property to identify it.\n\nExample Body:\n\n```\n    {\n      \"development\": {\n        \"use_mainbranch\": true\n      },\n      \"production\": {\n        \"enabled\": true,\n        \"use_mainbranch\": false,\n        \"name\": \"production\"\n      },\n      \"branch_types\": [\n        {\n          \"kind\": \"bugfix\",\n          \"enabled\": true,\n          \"prefix\": \"bugfix/\"\n        },\n        {\n          \"kind\": \"feature\",\n          \"enabled\": true,\n          \"prefix\": \"feature/\"\n        },\n        {\n          \"kind\": \"hotfix\",\n          \"prefix\": \"hotfix/\"\n        },\n        {\n          \"kind\": \"release\",\n          \"enabled\": false,\n        }\n      ]\n    }\n```",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The updated branching model configuration",
          "schema": {
            "$ref": "#/definitions/branching_model_settings"
          }
        },
        "400": {
          "description": "If the request contains invalid branching model configuration",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "401": {
          "description": "If the request was not authenticated",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If the authenticated user does not have admin access to the repository",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the repository does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "branching_model"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/commit/{node}": {
    "get": {
      "description": "Returns the specified commit.\n\nExample:\n\n```\n$ curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a1\n{\n    \"rendered\": {\n        \"message\": {\n        \"raw\": \"Add a GEORDI_OUTPUT_DIR setting\",\n        \"markup\": \"markdown\",\n        \"html\": \"<p>Add a GEORDI_OUTPUT_DIR setting</p>\",\n        \"type\": \"rendered\"\n        }\n    },\n    \"hash\": \"f7591a13eda445d9a9167f98eb870319f4b6c2d8\",\n    \"repository\": {\n        \"name\": \"geordi\",\n        \"type\": \"repository\",\n        \"full_name\": \"bitbucket/geordi\",\n        \"links\": {\n            \"self\": {\n                \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi\"\n            },\n            \"html\": {\n                \"href\": \"https://bitbucket.org/bitbucket/geordi\"\n            },\n            \"avatar\": {\n                \"href\": \"https://bytebucket.org/ravatar/%7B85d08b4e-571d-44e9-a507-fa476535aa98%7D?ts=1730260\"\n            }\n        },\n        \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"\n    },\n    \"links\": {\n        \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8\"\n        },\n        \"comments\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/comments\"\n        },\n        \"patch\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/patch/f7591a13eda445d9a9167f98eb870319f4b6c2d8\"\n        },\n        \"html\": {\n            \"href\": \"https://bitbucket.org/bitbucket/geordi/commits/f7591a13eda445d9a9167f98eb870319f4b6c2d8\"\n        },\n        \"diff\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diff/f7591a13eda445d9a9167f98eb870319f4b6c2d8\"\n        },\n        \"approve\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/approve\"\n        },\n        \"statuses\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/statuses\"\n        }\n    },\n    \"author\": {\n        \"raw\": \"Brodie Rao <a@b.c>\",\n        \"type\": \"author\",\n        \"user\": {\n            \"display_name\": \"Brodie Rao\",\n            \"uuid\": \"{9484702e-c663-4afd-aefb-c93a8cd31c28}\",\n            \"links\": {\n                \"self\": {\n                    \"href\": \"https://api.bitbucket.org/2.0/users/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D\"\n                },\n                \"html\": {\n                    \"href\": \"https://bitbucket.org/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D/\"\n                },\n                \"avatar\": {\n                    \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca/613070db-28b0-421f-8dba-ae8a87e2a5c7/128\"\n                }\n            },\n            \"type\": \"user\",\n            \"nickname\": \"brodie\",\n            \"account_id\": \"557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca\"\n        }\n    },\n    \"summary\": {\n        \"raw\": \"Add a GEORDI_OUTPUT_DIR setting\",\n        \"markup\": \"markdown\",\n        \"html\": \"<p>Add a GEORDI_OUTPUT_DIR setting</p>\",\n        \"type\": \"rendered\"\n    },\n    \"participants\": [],\n    \"parents\": [\n        {\n            \"type\": \"commit\",\n            \"hash\": \"f06941fec4ef6bcb0c2456927a0cf258fa4f899b\",\n            \"links\": {\n                \"self\": {\n                    \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\"\n                },\n                \"html\": {\n                    \"href\": \"https://bitbucket.org/bitbucket/geordi/commits/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\"\n                }\n            }\n        }\n    ],\n    \"date\": \"2012-07-16T19:37:54+00:00\",\n    \"message\": \"Add a GEORDI_OUTPUT_DIR setting\",\n    \"type\": \"commit\"\n}\n```",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The commit object",
          "schema": {
            "$ref": "#/definitions/commit"
          }
        },
        "404": {
          "description": "If the specified commit or repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "commits"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The commit's SHA1.",
        "in": "path",
        "name": "node",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/commit/{node}/approve": {
    "delete": {
      "description": "Redact the authenticated user's approval of the specified commit.\n\nThis operation is only available to users that have explicit access to\nthe repository. In contrast, just the fact that a repository is\npublicly accessible to users does not give them the ability to approve\ncommits.",
      "parameters": [],
      "responses": {
        "204": {
          "description": "An empty response indicating the authenticated user's approval has been withdrawn."
        },
        "404": {
          "description": "If the specified commit, or the repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "commits"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The commit's SHA1.",
        "in": "path",
        "name": "node",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Approve the specified commit as the authenticated user.\n\nThis operation is only available to users that have explicit access to\nthe repository. In contrast, just the fact that a repository is\npublicly accessible to users does not give them the ability to approve\ncommits.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The `participant` object recording that the authenticated user approved the commit.",
          "schema": {
            "$ref": "#/definitions/participant"
          }
        },
        "404": {
          "description": "If the specified commit, or the repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "commits"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/commit/{node}/comments": {
    "get": {
      "description": "Returns the commit's comments.\n\nThis includes both global and inline comments.\n\nThe default sorting is oldest to newest and can be overridden with\nthe `sort` query parameter.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "A paginated list of commit comments.",
          "schema": {
            "$ref": "#/definitions/paginated_commit_comments"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "commits"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The commit's SHA1.",
        "in": "path",
        "name": "node",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates new comment on the specified commit.\n\nTo post a reply to an existing comment, include the `parent.id` field:\n\n```\n$ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \\\n  -X POST -u evzijst \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"content\": {\"raw\": \"One more thing!\"},\n       \"parent\": {\"id\": 5728901}}'\n```",
      "parameters": [
        {
          "description": "This can either be the username or the UUID of the user,\nsurrounded by curly-braces, for example: `{user UUID}`.\n",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The specified comment.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/commit_comment"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The newly created comment.",
          "headers": {
            "Location": {
              "description": "The location of the newly created comment.",
              "type": "string"
            }
          }
        },
        "400": {
          "description": "If the comment was detected as spam, or if the parent comment is not attached to the same node as the new comment"
        },
        "404": {
          "description": "If a parent ID was passed in that cannot be found"
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "commits"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/commit/{node}/comments/{comment_id}": {
    "get": {
      "description": "Returns the specified commit comment.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The commit comment.",
          "schema": {
            "$ref": "#/definitions/commit_comment"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "commits"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The commit's SHA1.",
        "in": "path",
        "name": "node",
        "required": true,
        "type": "string"
      },
      {
        "description": "The id of the comment.",
        "in": "path",
        "name": "comment_id",
        "required": true,
        "type": "integer"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/commit/{node}/statuses": {
    "get": {
      "description": "Returns all statuses (e.g. build results) for a specific commit.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "A paginated list of all commit statuses for this commit.",
          "schema": {
            "$ref": "#/definitions/paginated_commitstatuses"
          }
        },
        "401": {
          "description": "If the repository is private and the request was not authenticated."
        },
        "404": {
          "description": "If the repository or commit does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories",
        "commitstatuses"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The commit's SHA1.",
        "in": "path",
        "name": "node",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/commit/{node}/statuses/build": {
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The commit's SHA1.",
        "in": "path",
        "name": "node",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new build status against the specified commit.\n\nIf the specified key already exists, the existing status object will\nbe overwritten.\n\nWhen creating a new commit status, you can use a URI template for the URL.\nTemplates are URLs that contain variable names that Bitbucket will\nevaluate at runtime whenever the URL is displayed anywhere similar to\nparameter substitution in\n[Bitbucket Connect](https://developer.atlassian.com/bitbucket/concepts/context-parameters.html).\nFor example, one could use `https://foo.com/builds/{repository.full_name}`\nwhich Bitbucket will turn into `https://foo.com/builds/foo/bar` at render time.\nThe context variables available are `repository` and `commit`.",
      "parameters": [
        {
          "description": "The new commit status object.",
          "in": "body",
          "name": "_body",
          "required": false,
          "schema": {
            "$ref": "#/definitions/commitstatus"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The newly created build status object.",
          "schema": {
            "$ref": "#/definitions/commitstatus"
          }
        },
        "401": {
          "description": "If the repository is private and the request was not authenticated."
        },
        "404": {
          "description": "If the repository, commit, or build status key does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories",
        "commitstatuses"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/commit/{node}/statuses/build/{key}": {
    "get": {
      "description": "Returns the specified build status for a commit.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The build status object with the specified key.",
          "schema": {
            "$ref": "#/definitions/commitstatus"
          }
        },
        "401": {
          "description": "If the repository is private and the request was not authenticated."
        },
        "404": {
          "description": "If the repository, commit, or build status key does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories",
        "commitstatuses"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The commit's SHA1.",
        "in": "path",
        "name": "node",
        "required": true,
        "type": "string"
      },
      {
        "description": "The build status' unique key",
        "in": "path",
        "name": "key",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Used to update the current status of a build status object on the\nspecific commit.\n\nThis operation can also be used to change other properties of the\nbuild status:\n\n* `state`\n* `name`\n* `description`\n* `url`\n* `refname`\n\nThe `key` cannot be changed.",
      "parameters": [
        {
          "description": "The updated build status object",
          "in": "body",
          "name": "_body",
          "required": false,
          "schema": {
            "$ref": "#/definitions/commitstatus"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The updated build status object.",
          "schema": {
            "$ref": "#/definitions/commitstatus"
          }
        },
        "401": {
          "description": "If the repository is private and the request was not authenticated."
        },
        "404": {
          "description": "If the repository or build does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories",
        "commitstatuses"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/commits": {
    "get": {
      "description": "These are the repository's commits. They are paginated and returned\nin reverse chronological order, similar to the output of `git log` and\n`hg log`. Like these tools, the DAG can be filtered.\n\n## GET /repositories/{username}/{repo_slug}/commits/\n\nReturns all commits in the repo in topological order (newest commit\nfirst). All branches and tags are included (similar to\n`git log --all` and `hg log`).\n\n## GET /repositories/{username}/{repo_slug}/commits/master\n\nReturns all commits on rev `master` (similar to `git log master`,\n`hg log master`).\n\n## GET /repositories/{username}/{repo_slug}/commits/dev?exclude=master\n\nReturns all commits on ref `dev`, except those that are reachable on\n`master` (similar to `git log dev ^master`).\n\n## GET /repositories/{username}/{repo_slug}/commits/?exclude=master\n\nReturns all commits in the repo that are not on master\n(similar to `git log --all ^master`).\n\n## GET /repositories/{username}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar\n\nReturns all commits that are on refs `foo` or `bar`, but not on `fu` or\n`fubar` (similar to `git log foo bar ^fu ^fubar`).\n\nAn optional `path` parameter can be specified that will limit the\nresults to commits that affect that path. `path` can either be a file\nor a directory. If a directory is specified, commits are returned that\nhave modified any file in the directory tree rooted by `path`. It is\nimportant to note that if the `path` parameter is specified, the commits\nreturned by this endpoint may no longer be a DAG, parent commits that\ndo not modify the path will be omitted from the response.\n\n## GET /repositories/{username}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master\n\nReturns all commits that are on refs `foo` or `bar`, but not on `master`\nthat changed the file README.md.\n\n## GET /repositories/{username}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master\n\nReturns all commits that are on refs `foo` or `bar`, but not on `master`\nthat changed to a file in any file in the directory src or its children.\n\nBecause the response could include a very large number of commits, it\nis paginated. Follow the 'next' link in the response to navigate to the\nnext page of commits. As with other paginated resources, do not\nconstruct your own links.\n\nWhen the include and exclude parameters are more than can fit in a\nquery string, clients can use a `x-www-form-urlencoded` POST instead.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "commits"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Identical to `GET /repositories/{username}/{repo_slug}/commits`,\nexcept that POST allows clients to place the include and exclude\nparameters in the request body to avoid URL length issues.\n\n**Note that this resource does NOT support new commit creation.**",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "commits"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/commits/{revision}": {
    "get": {
      "description": "These are the repository's commits. They are paginated and returned\nin reverse chronological order, similar to the output of `git log` and\n`hg log`. Like these tools, the DAG can be filtered.\n\n## GET /repositories/{username}/{repo_slug}/commits/\n\nReturns all commits in the repo in topological order (newest commit\nfirst). All branches and tags are included (similar to\n`git log --all` and `hg log`).\n\n## GET /repositories/{username}/{repo_slug}/commits/master\n\nReturns all commits on rev `master` (similar to `git log master`,\n`hg log master`).\n\n## GET /repositories/{username}/{repo_slug}/commits/dev?exclude=master\n\nReturns all commits on ref `dev`, except those that are reachable on\n`master` (similar to `git log dev ^master`).\n\n## GET /repositories/{username}/{repo_slug}/commits/?exclude=master\n\nReturns all commits in the repo that are not on master\n(similar to `git log --all ^master`).\n\n## GET /repositories/{username}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar\n\nReturns all commits that are on refs `foo` or `bar`, but not on `fu` or\n`fubar` (similar to `git log foo bar ^fu ^fubar`).\n\nAn optional `path` parameter can be specified that will limit the\nresults to commits that affect that path. `path` can either be a file\nor a directory. If a directory is specified, commits are returned that\nhave modified any file in the directory tree rooted by `path`. It is\nimportant to note that if the `path` parameter is specified, the commits\nreturned by this endpoint may no longer be a DAG, parent commits that\ndo not modify the path will be omitted from the response.\n\n## GET /repositories/{username}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master\n\nReturns all commits that are on refs `foo` or `bar`, but not on `master`\nthat changed the file README.md.\n\n## GET /repositories/{username}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master\n\nReturns all commits that are on refs `foo` or `bar`, but not on `master`\nthat changed to a file in any file in the directory src or its children.\n\nBecause the response could include a very large number of commits, it\nis paginated. Follow the 'next' link in the response to navigate to the\nnext page of commits. As with other paginated resources, do not\nconstruct your own links.\n\nWhen the include and exclude parameters are more than can fit in a\nquery string, clients can use a `x-www-form-urlencoded` POST instead.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "commits"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "revision",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Identical to `GET /repositories/{username}/{repo_slug}/commits`,\nexcept that POST allows clients to place the include and exclude\nparameters in the request body to avoid URL length issues.\n\n**Note that this resource does NOT support new commit creation.**",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "commits"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/components": {
    "get": {
      "description": "Returns the components that have been defined in the issue tracker.\n\nThis resource is only available on repositories that have the issue\ntracker enabled.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The components that have been defined in the issue tracker.",
          "schema": {
            "$ref": "#/definitions/paginated_components"
          }
        },
        "404": {
          "description": "The specified repository does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/components/{component_id}": {
    "get": {
      "description": "Returns the specified issue tracker component object.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The specified component object.",
          "schema": {
            "$ref": "#/definitions/component"
          }
        },
        "404": {
          "description": "The specified repository or component does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The component's id",
        "in": "path",
        "name": "component_id",
        "required": true,
        "type": "integer"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/default-reviewers": {
    "get": {
      "description": "Returns the repository's default reviewers.\n\nThese are the users that are automatically added as reviewers on every\nnew pull request that is created.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The paginated list of default reviewers"
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/default-reviewers/{target_username}": {
    "delete": {
      "description": "Removes a default reviewer from the repository.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "get": {
      "description": "Returns the specified reviewer.\n\nThis can be used to test whether a user is among the repository's\ndefault reviewers list. A 404 indicates that that specified user is not\na default reviewer.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the username or the UUID of the default reviewer,\nsurrounded by curly-braces, for example: `{account UUID}`.\n",
        "in": "path",
        "name": "target_username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Adds the specified user to the repository's list of default\nreviewers.\n\nThis method is idempotent. Adding a user a second time has no effect.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/deploy-keys": {
    "get": {
      "description": "Returns all deploy-keys belonging to a repository.\n\nExample:\n```\n$ curl -H \"Authorization <auth header>\" \\\nhttps://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys\n\nOutput:\n{\n    \"pagelen\": 10,\n    \"values\": [\n        {\n            \"id\": 123,\n            \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5\",\n            \"label\": \"mykey\",\n            \"type\": \"deploy_key\",\n            \"created_on\": \"2018-08-15T23:50:59.993890+00:00\",\n            \"repository\": {\n                \"full_name\": \"mleu/test\",\n                \"name\": \"test\",\n                \"type\": \"repository\",\n                \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"\n            },\n            \"links\":{\n                \"self\":{\n                    \"href\": \"https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/123\"\n                }\n            }\n            \"last_used\": null,\n            \"comment\": \"mleu@C02W454JHTD8\"\n        }\n    ],\n    \"page\": 1,\n    \"size\": 1\n}\n```",
      "parameters": [],
      "responses": {
        "200": {
          "description": "Deploy keys matching the repository",
          "schema": {
            "$ref": "#/definitions/paginated_deploy_keys"
          }
        },
        "403": {
          "description": "If the specified user or repository is not accessible to the current user"
        },
        "404": {
          "description": "If the specified user or repository does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository",
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "deploy"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Create a new deploy key in a repository.\n\nExample:\n```\n$ curl -XPOST \\\n-H \"Authorization <auth header>\" \\\n-H \"Content-type: application/json\" \\\nhttps://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys -d \\\n'{\n    \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8\",\n    \"label\": \"mydeploykey\"\n}'\n\nOutput:\n{\n    \"id\": 123,\n    \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5\",\n    \"label\": \"mydeploykey\",\n    \"type\": \"deploy_key\",\n    \"created_on\": \"2018-08-15T23:50:59.993890+00:00\",\n    \"repository\": {\n        \"full_name\": \"mleu/test\",\n        \"name\": \"test\",\n        \"type\": \"repository\",\n        \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"\n    },\n    \"links\":{\n        \"self\":{\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/123\"\n        }\n    }\n    \"last_used\": null,\n    \"comment\": \"mleu@C02W454JHTD8\"\n}\n```",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The deploy key that was created",
          "schema": {
            "$ref": "#/definitions/deploy_key"
          }
        },
        "400": {
          "description": "Invalid deploy key inputs"
        },
        "403": {
          "description": "If the specified user or repository is not accessible to the current user"
        },
        "404": {
          "description": "If the specified user or repository does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository",
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "deploy"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/deploy-keys/{key_id}": {
    "delete": {
      "description": "This deletes a deploy key from a repository.\n\nExample:\n```\n$ curl -XDELETE \\\n-H \"Authorization <auth header>\" \\\nhttps://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234\n```",
      "parameters": [],
      "responses": {
        "204": {
          "description": "The key has been deleted"
        },
        "403": {
          "description": "If the current user does not have permission to delete a key for the specified user"
        },
        "404": {
          "description": "If the specified user, repository, or deploy key does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository",
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "deploy"
      ]
    },
    "get": {
      "description": "Returns the deploy key belonging to a specific key.\n\nExample:\n```\n$ curl -H \"Authorization <auth header>\" \\\nhttps://api.bitbucket.org/2.0/repositories/mleu/test/deploy-key/1234\n\nOutput:\n{\n    \"comment\": \"mleu@C02W454JHTD8\",\n    \"last_used\": null,\n    \"links\": {\n        \"self\": {\n            \"href\": https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-key/1234\"\n        }\n    },\n    \"repository\": {\n        \"full_name\": \"mleu/test\",\n        \"name\": \"test\",\n        \"type\": \"repository\",\n        \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"\n    },\n    \"label\": \"mykey\",\n    \"created_on\": \"2018-08-15T23:50:59.993890+00:00\",\n    \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5\",\n    \"id\": 1234,\n    \"type\": \"deploy_key\"\n}\n```",
      "parameters": [],
      "responses": {
        "200": {
          "description": "Deploy key matching the key ID",
          "schema": {
            "$ref": "#/definitions/deploy_key"
          }
        },
        "403": {
          "description": "If the specified user or repository is not accessible to the current user"
        },
        "404": {
          "description": "If the specified user or repository does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository",
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "deploy"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The key ID matching the deploy key.",
        "in": "path",
        "name": "key_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Create a new deploy key in a repository.\n\nThe same key needs to be passed in but the comment and label can change.\n\nExample:\n```\n$ curl -XPUT \\\n-H \"Authorization <auth header>\" \\\n-H \"Content-type: application/json\" \\\nhttps://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234 -d \\\n'{\n    \"label\": \"newlabel\",\n    \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 newcomment\",\n}'\n\nOutput:\n{\n    \"comment\": \"newcomment\",\n    \"last_used\": null,\n    \"links\": {\n        \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234\"\n        }\n    },\n    \"repository\": {\n        \"full_name\": \"mleu/test\",\n        \"name\": \"test\",\n        \"type\": \"repository\",\n        \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"\n    },\n    \"label\": \"newlabel\",\n    \"created_on\": \"2018-08-15T23:50:59.993890+00:00\",\n    \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5\",\n    \"id\": 1234,\n    \"type\": \"deploy_key\"\n}\n```",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The newly updated deploy key.",
          "schema": {
            "$ref": "#/definitions/deploy_key"
          }
        },
        "400": {
          "description": "If the submitted key or related value is invalid",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If the current user does not have permission to add a key for the specified user"
        },
        "404": {
          "description": "If the specified user, repository, or deploy key does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository",
            "repository:admin"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "deploy"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/diff/{spec}": {
    "get": {
      "description": "Produces a raw, git-style diff for either a single commit (diffed\nagainst its first parent), or a revspec of 2 commits (e.g.\n`3a8b42..9ff173` where the first commit represents the source and the\nsecond commit the destination).\n\nIn case of the latter (diffing a revspec), a 3-way diff, or merge diff,\nis computed. This shows the changes introduced by the left branch\n(`3a8b42` in our example) as compared againt the right branch\n(`9ff173`).\n\nThis is equivalent to merging the left branch into the right branch and\nthen computing the diff of the merge commit against its first parent\n(the right branch). This follows the same behavior as pull requests\nthat also show this style of 3-way, or merge diff.\n\nWhile similar to patches, diffs:\n\n* Don't have a commit header (username, commit message, etc)\n* Support the optional `path=foo/bar.py` query param to filter\n  the diff to just that one file diff\n\nThe raw diff is returned as-is, in whatever encoding the files in the\nrepository use. It is not decoded into unicode. As such, the\ncontent-type is `text/plain`.",
      "parameters": [
        {
          "description": "Generate diffs with <n> lines of context instead of the usual three",
          "in": "query",
          "name": "context",
          "required": false,
          "type": "integer"
        },
        {
          "description": "Limit the diff to a particular file (this parameter\ncan be repeated for multiple paths)",
          "in": "query",
          "name": "path",
          "required": false,
          "type": "string"
        },
        {
          "description": "Generate diffs that ignore whitespace",
          "in": "query",
          "name": "ignore_whitespace",
          "required": false,
          "type": "boolean"
        },
        {
          "description": "Generate diffs that include binary files,true if omitted.",
          "in": "query",
          "name": "binary",
          "required": false,
          "type": "boolean"
        }
      ],
      "responses": {
        "200": {
          "description": "The raw diff"
        },
        "555": {
          "description": "If the diff was too large and timed out.\n\nSince this endpoint does not employ any form of pagination, but\ninstead returns the diff as a single document, it can run into\ntrouble on very large diffs. If Bitbucket times out in cases\nlike these, a 555 status code is returned.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "commits"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "spec",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/diffstat/{spec}": {
    "get": {
      "description": "Returns the diff stat for the specified commit.\n\nDiff stat responses contain a record for every path modified by the\ncommit and lists the number of lines added and removed for each file.\n\n\nExample:\n```\ncurl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diffstat/d222fa2..e174964\n{\n    \"pagelen\": 500,\n    \"values\": [\n        {\n            \"type\": \"diffstat\",\n            \"status\": \"modified\",\n            \"lines_removed\": 1,\n            \"lines_added\": 2,\n            \"old\": {\n                \"path\": \"setup.py\",\n                \"type\": \"commit_file\",\n                \"links\": {\n                    \"self\": {\n                        \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/e1749643d655d7c7014001a6c0f58abaf42ad850/setup.py\"\n                    }\n                }\n            },\n            \"new\": {\n                \"path\": \"setup.py\",\n                \"type\": \"commit_file\",\n                \"links\": {\n                    \"self\": {\n                        \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/d222fa235229c55dad20b190b0b571adf737d5a6/setup.py\"\n                    }\n                }\n            }\n        }\n    ],\n    \"page\": 1,\n    \"size\": 1\n}\n```",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The diff stats",
          "schema": {
            "$ref": "#/definitions/paginated_diffstats"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": []
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "A commit SHA (e.g. `3a8b42`) or a commit range using double dot\nnotation (e.g. `3a8b42..9ff173`).\n",
        "in": "path",
        "name": "spec",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      },
      {
        "description": "Generate diffs that ignore whitespace",
        "in": "query",
        "name": "ignore_whitespace",
        "required": false,
        "type": "boolean"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/downloads": {
    "get": {
      "description": "Returns a list of download links associated with the repository.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "downloads"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Upload new download artifacts.\n\nTo upload files, perform a `multipart/form-data` POST containing one\nor more `files` fields:\n\n    $ echo Hello World > hello.txt\n    $ curl -s -u evzijst -X POST https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads -F files=@hello.txt\n\nWhen a file is uploaded with the same name as an existing artifact,\nthen the existing file will be replaced.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "downloads"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/downloads/{filename}": {
    "delete": {
      "description": "Deletes the specified download artifact from the repository.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "downloads"
      ]
    },
    "get": {
      "description": "Return a redirect to the contents of a download artifact.\n\nThis endpoint returns the actual file contents and not the artifact's\nmetadata.\n\n    $ curl -s -L https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads/hello.txt\n    Hello World",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "downloads"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "filename",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/filehistory/{node}/{path}": {
    "get": {
      "description": "Returns a paginated list of commits that modified the specified file.\n\nCommits are returned in reverse chronological order. This is roughly\nequivalent to the following commands:\n\n    $ git log --follow --date-order <sha> <path>\n\n    $ hg log --follow <path>\n\nBy default, Bitbucket will follow renames and the path name in the\nreturned entries reflects that. This can be turned off using the\n`?renames=false` query parameter.\n\nResults are returned in descending chronological order by default, and\nlike most endpoints you can\n[filter and sort](../../../../../../meta/filtering) the response to\nonly provide exactly the data you want.\n\nFor example, if you wanted to find commits made before 2011-05-18\nagainst a file named `README.rst`, but you only wanted the path and\ndate, your query would look like this:\n\n```\n$ curl 'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst'\\\n  '?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18'\n{\n  \"values\": [\n    {\n      \"commit\": {\n        \"date\": \"2011-05-17T07:32:09+00:00\"\n      },\n      \"path\": \"README.rst\"\n    },\n    {\n      \"commit\": {\n        \"date\": \"2011-05-16T06:33:28+00:00\"\n      },\n      \"path\": \"README.txt\"\n    },\n    {\n      \"commit\": {\n        \"date\": \"2011-05-16T06:15:39+00:00\"\n      },\n      \"path\": \"README.txt\"\n    }\n  ]\n}\n```\n\nIn the response you can see that the file was renamed to `README.rst`\nby the commit made on 2011-05-16, and was previously named `README.txt`.",
      "parameters": [
        {
          "description": "\nWhen `true`, Bitbucket will follow the history of the file across\nrenames (this is the default behavior). This can be turned off by\nspecifying `false`.",
          "in": "query",
          "name": "renames",
          "required": false,
          "type": "string"
        },
        {
          "description": "\nQuery string to narrow down the response as per\n[filtering and sorting](../../../../../../meta/filtering).",
          "in": "query",
          "name": "q",
          "required": false,
          "type": "string"
        },
        {
          "description": "\nName of a response property sort the result by as per\n[filtering and sorting](../../../../../../meta/filtering#query-sort).\n",
          "in": "query",
          "name": "sort",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of commits that modified the specified file",
          "schema": {
            "$ref": "#/definitions/paginated_files"
          }
        },
        "404": {
          "description": "If the repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "source",
        "repositories"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "node",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "path",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/forks": {
    "get": {
      "description": "Returns a paginated list of all the forks of the specified\nrepository.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "All forks.",
          "schema": {
            "$ref": "#/definitions/paginated_repositories"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new fork of the specified repository.\n\nBy default, forks are created under the authenticated user's account\nwith the same name and slug of the original repository.\n\n```\n$ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/forks\n\n{\n  \"scm\": \"git\",\n  \"full_name\": \"jdoe/dogslow\",\n  \"parent\": {\n    \"full_name\": \"evzijst/dogslow\",\n    ...\n  },\n  ...\n}\n```\n\nIf you already have a repo with that name, then a 400 is returned and\nyou'll need to specify a custom name for the new fork:\n\n```\n$ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/forks \\\n  -H 'Content-Type: application/json' -d '{\n    \"name\": \"dogslow_fork\"\n}'\n```\n\nWhen you specify a value for `name`, it will also affect the `slug`.\nThe `slug` is reflected in the repository URL of the new fork. It is\nderived from `name` by substituting non-ASCII characters, removes\nwhitespace, and changes characters to lower case. For example,\n`My repo` would turn into `my_repo`.\n\n## Forking a repository into a team account\n\nTo create a fork into a team account, specify the new owner's account\nexplicitly as part of the request body. This prevents forked\nrepositories from being owned by the authenticated user submitting the\nrequest:\n\n```\n$ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \\\n  -H 'Content-Type: application/json' -d '{\n    \"name\": \"bbql_fork\",\n    \"owner\": {\n      \"username\": \"atlassian\"\n    }\n}'\n```\n\nTo fork a repository into the same team, also specify a new `name`.\n\nYou need contributor access to create new forks within a team account.\n\n\n## Change the properties of a new fork\n\nBy default the fork inherits most of its properties from the parent.\nHowever, since the optional POST body document follows the normal\n`repository` JSON schema and you can override the new fork's\nproperties.\n\nProperties that can be overridden include:\n\n* description\n* fork_policy\n* language\n* mainbranch\n* is_private (note that a private repo's fork_policy might prohibit\n  the creation of public forks, in which `is_private=False` would fail)\n* has_issues (to initialize or disable the new repo's issue tracker --\n  note that the actual contents of the parent repository's issue\n  tracker are not copied during forking)\n* has_wiki (to initialize or disable the new repo's wiki --\n  note that the actual contents of the parent repository's wiki are not\n  copied during forking)\n* project (only teams have projects and when forking into a private\n  project, the fork's `is_private` must be `true`)\n\nProperties that cannot be modified include:\n\n* scm\n* parent\n* full_name",
      "parameters": [
        {
          "description": "A repository object. This can be left blank.",
          "in": "body",
          "name": "_body",
          "required": false,
          "schema": {
            "$ref": "#/definitions/repository"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The newly created fork.",
          "examples": {
            "application/json": {
              "created_on": "2018-06-20T23:17:33.616037+00:00",
              "description": "A repository for my bits and bobs",
              "fork_policy": "allow_forks",
              "full_name": "example-username/bits_and_bobs",
              "has_issues": false,
              "has_wiki": false,
              "is_private": true,
              "language": "python",
              "links": {
                "avatar": {
                  "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                },
                "branches": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/refs/branches"
                },
                "clone": [
                  {
                    "href": "https://bitbucket.org/example-username/bits_and_bobs.git",
                    "name": "https"
                  },
                  {
                    "href": "git@bitbucket.org:example-username/bits_and_bobs.git",
                    "name": "ssh"
                  }
                ],
                "commits": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commits"
                },
                "downloads": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/downloads"
                },
                "forks": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/forks"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/bits_and_bobs"
                },
                "pullrequests": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                },
                "source": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/src"
                },
                "tags": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/refs/tags"
                },
                "watchers": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/watchers"
                }
              },
              "mainbranch": {
                "name": "master",
                "type": "branch"
              },
              "name": "bits_and_bobs",
              "owner": {
                "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
                "display_name": "Example Username",
                "links": {
                  "avatar": {
                    "href": "https://bitbucket.org/account/example-username/avatar/"
                  },
                  "html": {
                    "href": "https://bitbucket.org/example-username/"
                  },
                  "self": {
                    "href": "https://api.bitbucket.org/2.0/users/example-username"
                  }
                },
                "nickname": "example-username",
                "type": "user",
                "username": "example-username",
                "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
              },
              "scm": "git",
              "size": 33348,
              "slug": "bits_and_bobs",
              "type": "repository",
              "updated_on": "2018-06-20T23:17:33.616037+00:00",
              "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}",
              "website": "www.example.com"
            }
          },
          "headers": {
            "Location": {
              "description": "The URL of the newly created fork",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/repository"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/hooks": {
    "get": {
      "description": "Returns a paginated list of webhooks installed on this repository.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The paginated list of installed webhooks.",
          "schema": {
            "$ref": "#/definitions/paginated_webhook_subscriptions"
          }
        },
        "403": {
          "description": "If the authenticated user does not have permission to access the webhooks.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories",
        "webhooks"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new webhook on the specified repository.\n\nExample:\n\n```\n$ curl -X POST -u credentials -H 'Content-Type: application/json'           https://api.bitbucket.org/2.0/repositories/username/slug/hooks           -d '\n    {\n      \"description\": \"Webhook Description\",\n      \"url\": \"https://example.com/\",\n      \"active\": true,\n      \"events\": [\n        \"repo:push\",\n        \"issue:created\",\n        \"issue:updated\"\n      ]\n    }'\n```\n\nNote that this call requires the webhook scope, as well as any scope\nthat applies to the events that the webhook subscribes to. In the\nexample above that means: `webhook`, `repository` and `issue`.\n\nAlso note that the `url` must properly resolve and cannot be an\ninternal, non-routed address.",
      "parameters": [],
      "responses": {
        "201": {
          "description": "If the webhook was registered successfully.",
          "headers": {
            "Location": {
              "description": "The URL of new newly created webhook.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/webhook_subscription"
          }
        },
        "403": {
          "description": "If the authenticated user does not have permission to install webhooks on the specified repository.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories",
        "webhooks"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/hooks/{uid}": {
    "delete": {
      "description": "Deletes the specified webhook subscription from the given\nrepository.",
      "parameters": [
        {
          "description": "The installed webhook's id",
          "in": "path",
          "name": "uid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "When the webhook was deleted successfully"
        },
        "403": {
          "description": "If the authenticated user does not have permission to delete the webhook.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the webhook or repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories",
        "webhooks"
      ]
    },
    "get": {
      "description": "Returns the webhook with the specified id installed on the specified\nrepository.",
      "parameters": [
        {
          "description": "The installed webhook's id.",
          "in": "path",
          "name": "uid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The webhook subscription object.",
          "schema": {
            "$ref": "#/definitions/webhook_subscription"
          }
        },
        "404": {
          "description": "If the webhook or repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories",
        "webhooks"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "uid",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Updates the specified webhook subscription.\n\nThe following properties can be mutated:\n\n* `description`\n* `url`\n* `active`\n* `events`",
      "parameters": [
        {
          "description": "The installed webhook's id",
          "in": "path",
          "name": "uid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The webhook subscription object.",
          "schema": {
            "$ref": "#/definitions/webhook_subscription"
          }
        },
        "403": {
          "description": "If the authenticated user does not have permission to update the webhook.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the webhook or repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories",
        "webhooks"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/issues": {
    "get": {
      "description": "Returns the issues in the issue tracker.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "A paginated list of the issues matching any filter criteria that were provided.",
          "schema": {
            "$ref": "#/definitions/paginated_issues"
          }
        },
        "404": {
          "description": "The specified repository does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new issue.\n\nThis call requires authentication. Private repositories or private\nissue trackers require the caller to authenticate with an account that\nhas appropriate authorization.\n\nThe authenticated user is used for the issue's `reporter` field.",
      "parameters": [
        {
          "description": "The new issue. The only required element is `title`. All other elements can be omitted from the body.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/issue"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The newly created issue.",
          "headers": {
            "Location": {
              "description": "The (absolute) URL of the newly created issue.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/issue"
          }
        },
        "401": {
          "description": "When the request wasn't authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "When the authenticated user isn't authorized to create the issue.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/issues/{issue_id}": {
    "delete": {
      "description": "Deletes the specified issue. This requires write access to the\nrepository.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The issue object.",
          "schema": {
            "$ref": "#/definitions/issue"
          }
        },
        "403": {
          "description": "When the authenticated user isn't authorized to delete the issue.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository or issue does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "get": {
      "description": "Returns the specified issue.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The issue object.",
          "schema": {
            "$ref": "#/definitions/issue"
          }
        },
        "403": {
          "description": "When the authenticated user isn't authorized to access the issue.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository or issue does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "410": {
          "description": "The specified issue is unavailable.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The issue id",
        "in": "path",
        "name": "issue_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Modifies the issue.\n\n```\n$ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \\\n  -u evzijst -s -X PUT -H 'Content-Type: application/json' \\\n  -d '{\n  \"title\": \"Updated title\",\n  \"assignee\": {\n    \"username\": \"evzijst\"\n  },\n  \"priority\": \"minor\",\n  \"version\": {\n    \"name\": \"1.0\"\n  },\n  \"component\": null\n}'\n```\n\nThis example changes the `title`, `assignee`, `priority` and the\n`version`. It also removes the value of the `component` from the issue\nby setting the field to `null`. Any field not present keeps its existing\nvalue.\n\nEach time an issue is edited in the UI or through the API, an immutable\nchange record is created under the `/issues/123/changes` endpoint. It\nalso has a comment associated with the change.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The updated issue object.",
          "schema": {
            "$ref": "#/definitions/issue"
          }
        },
        "403": {
          "description": "When the authenticated user isn't authorized to access the issue.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository or issue does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/issues/{issue_id}/attachments": {
    "get": {
      "description": "Returns all attachments for this issue.\n\nThis returns the files' meta data. This does not return the files'\nactual contents.\n\nThe files are always ordered by their upload date.",
      "parameters": [
        {
          "description": "The issue's id",
          "in": "path",
          "name": "issue_id",
          "required": true,
          "type": "integer"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of all attachments for this issue.",
          "schema": {
            "$ref": "#/definitions/paginated_issue_attachments"
          }
        },
        "401": {
          "description": "If the issue tracker is private and the request was not authenticated."
        },
        "404": {
          "description": "The specified repository or issue does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "issue_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Upload new issue attachments.\n\nTo upload files, perform a `multipart/form-data` POST containing one\nor more file fields.\n\nWhen a file is uploaded with the same name as an existing attachment,\nthen the existing file will be replaced.",
      "parameters": [
        {
          "description": "The issue's id",
          "in": "path",
          "name": "issue_id",
          "required": true,
          "type": "integer"
        }
      ],
      "responses": {
        "201": {
          "description": "An empty response document.",
          "headers": {
            "Location": {
              "description": "The URL to the issue's collection of attachments.",
              "type": "string"
            }
          }
        },
        "400": {
          "description": "If no files were uploaded, or if the wrong `Content-Type` was used."
        },
        "401": {
          "description": "If the issue tracker is private and the request was not authenticated."
        },
        "404": {
          "description": "The specified repository or issue does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/issues/{issue_id}/attachments/{path}": {
    "delete": {
      "description": "Deletes an attachment.",
      "parameters": [],
      "responses": {
        "204": {
          "description": "Indicates that the deletion was successful"
        },
        "401": {
          "description": "If the issue tracker is private and the request was not authenticated."
        },
        "404": {
          "description": "The specified repository or issue does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "get": {
      "description": "Returns the contents of the specified file attachment.\n\nNote that this endpoint does not return a JSON response, but instead\nreturns a redirect pointing to the actual file that in turn will return\nthe raw contents.\n\nThe redirect URL contains a one-time token that has a limited lifetime.\nAs a result, the link should not be persisted, stored, or shared.",
      "parameters": [],
      "responses": {
        "302": {
          "description": "A redirect to the file's contents",
          "headers": {
            "Location": {
              "type": "string"
            }
          }
        },
        "401": {
          "description": "If the issue tracker is private and the request was not authenticated."
        },
        "404": {
          "description": "The specified repository or issue does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "path",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "issue_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/issues/{issue_id}/changes": {
    "get": {
      "description": "Returns the list of all changes that have been made to the specified\nissue. Changes are returned in chronological order with the oldest\nchange first.\n\nEach time an issue is edited in the UI or through the API, an immutable\nchange record is created under the `/issues/123/changes` endpoint. It\nalso has a comment associated with the change.\n\nNote that this operation is changing significantly, due to privacy changes.\nSee the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api)\nfor details.\n\n```\n$ curl -s https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes - | jq .\n\n{\n  \"pagelen\": 20,\n  \"values\": [\n    {\n      \"changes\": {\n        \"priority\": {\n          \"new\": \"trivial\",\n          \"old\": \"major\"\n        },\n        \"assignee\": {\n          \"new\": \"\",\n          \"old\": \"evzijst\"\n        },\n        \"assignee_account_id\": {\n          \"new\": \"\",\n          \"old\": \"557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\"\n        },\n        \"kind\": {\n          \"new\": \"enhancement\",\n          \"old\": \"bug\"\n        }\n      },\n      \"links\": {\n        \"self\": {\n          \"href\": \"https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes/2\"\n        },\n        \"html\": {\n          \"href\": \"https://bitbucket.org/evzijst/dogslow/issues/1#comment-2\"\n        }\n      },\n      \"issue\": {\n        \"links\": {\n          \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1\"\n          }\n        },\n        \"type\": \"issue\",\n        \"id\": 1,\n        \"repository\": {\n          \"links\": {\n            \"self\": {\n              \"href\": \"https://api.bitbucket.org/2.0/repositories/evzijst/dogslow\"\n            },\n            \"html\": {\n              \"href\": \"https://bitbucket.org/evzijst/dogslow\"\n            },\n            \"avatar\": {\n              \"href\": \"https://bitbucket.org/evzijst/dogslow/avatar/32/\"\n            }\n          },\n          \"type\": \"repository\",\n          \"name\": \"dogslow\",\n          \"full_name\": \"evzijst/dogslow\",\n          \"uuid\": \"{988b17c6-1a47-4e70-84ee-854d5f012bf6}\"\n        },\n        \"title\": \"Updated title\"\n      },\n      \"created_on\": \"2018-03-03T00:35:28.353630+00:00\",\n      \"user\": {\n        \"username\": \"evzijst\",\n        \"nickname\": \"evzijst\",\n        \"display_name\": \"evzijst\",\n        \"type\": \"user\",\n        \"uuid\": \"{aaa7972b-38af-4fb1-802d-6e3854c95778}\",\n        \"links\": {\n          \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"\n          },\n          \"html\": {\n            \"href\": \"https://bitbucket.org/evzijst/\"\n          },\n          \"avatar\": {\n            \"href\": \"https://bitbucket.org/account/evzijst/avatar/32/\"\n          }\n        }\n      },\n      \"message\": {\n        \"raw\": \"Removed assignee, changed kind and priority.\",\n        \"markup\": \"markdown\",\n        \"html\": \"<p>Removed assignee, changed kind and priority.</p>\",\n        \"type\": \"rendered\"\n      },\n      \"type\": \"issue_change\",\n      \"id\": 2\n    }\n  ],\n  \"page\": 1\n}\n```\n\nChanges support [filtering and sorting](../../../meta/filtering) that\ncan be used to search for specific changes. For instance, to see\nwhen an issue transitioned to \"resolved\":\n\n```\n$ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \\\n   -G --data-urlencode='q=changes.state.new = \"resolved\"'\n```\n\nThis resource is only available on repositories that have the issue\ntracker enabled.\n\nN.B.\n\nThe `changes.assignee` and `changes.assignee_account_id` fields are not\na `user` object. Instead, they contain the raw `username` and\n`account_id` of the user. This is to protect the integrity of the audit\nlog even after a user account gets deleted.\n\nThe `changes.assignee` field is deprecated will disappear in the\nfuture. Use `changes.assignee_account_id` instead.",
      "parameters": [
        {
          "description": "\nQuery string to narrow down the response. See\n[filtering and sorting](../../../meta/filtering) for details.",
          "in": "query",
          "name": "q",
          "required": false,
          "type": "string"
        },
        {
          "description": "\nName of a response property to sort results. See\n[filtering and sorting](../../../meta/filtering#query-sort)\nfor details.\n",
          "in": "query",
          "name": "sort",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "Returns all the issue changes that were made on the specified issue.",
          "schema": {
            "$ref": "#/definitions/paginated_log_entries"
          }
        },
        "404": {
          "description": "The specified repository or issue does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The issue id",
        "in": "path",
        "name": "issue_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Makes a change to the specified issue.\n\nFor example, to change an issue's state and assignee, create a new\nchange object that modifies these fields:\n\n```\ncurl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \\\n  -s -u evzijst -X POST -H \"Content-Type: application/json\" \\\n  -d '{\n    \"changes\": {\n      \"assignee_account_id\": {\n        \"new\": \"557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\"\n      },\n      \"state\": {\n        \"new\": 'resolved\"\n      }\n    }\n    \"message\": {\n      \"raw\": \"This is now resolved.\"\n    }\n  }'\n```\n\nThe above example also includes a custom comment to go alongside the\nchange. This comment will also be visible on the issue page in the UI.\n\nThe fields of the `changes` object are strings, not objects. This\nallows for immutable change log records, even after user accounts,\nmilestones, or other objects recorded in a change entry, get renamed or\ndeleted.\n\nThe `assignee_account_id` field stores the account id. When POSTing a\nnew change and changing the assignee, the client should therefore use\nthe user's account_id in the `changes.assignee_account_id.new` field.\n\nThis call requires authentication. Private repositories or private\nissue trackers require the caller to authenticate with an account that\nhas appropriate authorization.",
      "parameters": [
        {
          "description": "The new issue state change. The only required elements are `changes.[].new`. All other elements can be omitted from the body.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/issue_change"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The newly created issue change.",
          "headers": {
            "Location": {
              "description": "The (absolute) URL of the newly created issue change.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/issue_change"
          }
        },
        "401": {
          "description": "When the request wasn't authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "When the authenticated user isn't authorized to modify the issue.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository or issue does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/issues/{issue_id}/changes/{change_id}": {
    "get": {
      "description": "Returns the specified issue change object.\n\nThis resource is only available on repositories that have the issue\ntracker enabled.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The specified issue change object.",
          "schema": {
            "$ref": "#/definitions/issue_change"
          }
        },
        "404": {
          "description": "The specified repository or issue change does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The issue change id",
        "in": "path",
        "name": "change_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "The issue id",
        "in": "path",
        "name": "issue_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/issues/{issue_id}/comments": {
    "get": {
      "description": "Returns a paginated list of all comments that were made on the\nspecified issue.\n\nThe default sorting is oldest to newest and can be overridden with\nthe `sort` query parameter.\n\nThis endpoint also supports filtering and sorting of the results. See\n[filtering and sorting](../../../../../../meta/filtering) for more details.",
      "parameters": [
        {
          "description": "This can either be the username or the UUID of the user,\nsurrounded by curly-braces, for example: `{user UUID}`.\n",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "\nQuery string to narrow down the response as per\n[filtering and sorting](../../../../../../meta/filtering).",
          "in": "query",
          "name": "q",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of issue comments.",
          "schema": {
            "$ref": "#/definitions/paginated_issue_comments"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "issue_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new issue comment.\n\n```\n$ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \\\n  -X POST -u evzijst \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"content\": {\"raw\": \"Lorem ipsum.\"}}'\n```",
      "parameters": [
        {
          "description": "This can either be the username or the UUID of the user,\nsurrounded by curly-braces, for example: `{user UUID}`.\n",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The new issue comment object.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/issue_comment"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The newly created comment.",
          "headers": {
            "Location": {
              "description": "The location of the newly issue comment.",
              "type": "string"
            }
          }
        },
        "400": {
          "description": "If the input was invalid, or if the comment being created is detected as spam ",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/issues/{issue_id}/comments/{comment_id}": {
    "delete": {
      "description": "Deletes the specified comment.",
      "parameters": [
        {
          "description": "This can either be the username or the UUID of the user,\nsurrounded by curly-braces, for example: `{user UUID}`.\n",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The ID of the issue that is being queried.\n",
          "in": "path",
          "name": "issue_id",
          "required": true,
          "type": "string"
        },
        {
          "description": "The updated comment.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/issue_comment"
          }
        }
      ],
      "responses": {
        "204": {
          "description": "Indicates successful deletion."
        }
      },
      "security": [
        {
          "oauth2": [
            "issue:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "get": {
      "description": "Returns the specified issue comment object.",
      "parameters": [
        {
          "description": "This can either be the username or the UUID of the user,\nsurrounded by curly-braces, for example: `{user UUID}`.\n",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The ID of the issue that is being queried.\n",
          "in": "path",
          "name": "issue_id",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The issue comment.",
          "schema": {
            "$ref": "#/definitions/issue_comment"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "comment_id",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "issue_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Updates the content of the specified issue comment. Note that only\nthe `content.raw` field can be modified.\n\n```\n$ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \\\n  -X PUT -u evzijst \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"content\": {\"raw\": \"Lorem ipsum.\"}'\n```",
      "parameters": [
        {
          "description": "This can either be the username or the UUID of the user,\nsurrounded by curly-braces, for example: `{user UUID}`.\n",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The ID of the issue that is being queried.\n",
          "in": "path",
          "name": "issue_id",
          "required": true,
          "type": "string"
        },
        {
          "description": "The updated comment.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/issue_comment"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The updated issue comment.",
          "schema": {
            "$ref": "#/definitions/issue_comment"
          }
        },
        "400": {
          "description": "If the input was invalid, or if the update to the comment is detected as spam ",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/issues/{issue_id}/vote": {
    "delete": {
      "description": "Retract your vote.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue:write",
            "account:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "get": {
      "description": "Check whether the authenticated user has voted for this issue.\nA 204 status code indicates that the user has voted, while a 404\nimplies they haven't.",
      "parameters": [],
      "responses": {
        "204": {
          "description": "If the authenticated user has not voted for this issue.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "401": {
          "description": "When the request wasn't authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the authenticated user has not voted for this issue, or when the repo does not exist, or does not have an issue tracker.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue",
            "account"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The issue id",
        "in": "path",
        "name": "issue_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Vote for this issue.\n\nTo cast your vote, do an empty PUT. The 204 status code indicates that\nthe operation was successful.",
      "parameters": [],
      "responses": {
        "204": {
          "description": "Indicating the authenticated user has cast their vote successfully.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "401": {
          "description": "When the request wasn't authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository or issue does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue",
            "account:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/issues/{issue_id}/watch": {
    "delete": {
      "description": "Stop watching this issue.",
      "parameters": [],
      "responses": {
        "204": {
          "description": "Indicates that the authenticated user successfully stopped watching this issue.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "401": {
          "description": "When the request wasn't authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository or issue does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue:write",
            "account:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "get": {
      "description": "Indicated whether or not the authenticated user is watching this\nissue.",
      "parameters": [],
      "responses": {
        "204": {
          "description": "If the authenticated user is watching this issue.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "401": {
          "description": "When the request wasn't authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the authenticated user is not watching this issue, or when the repo does not exist, or does not have an issue tracker.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue",
            "account"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The issue id",
        "in": "path",
        "name": "issue_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Start watching this issue.\n\nTo start watching this issue, do an empty PUT. The 204 status code\nindicates that the operation was successful.",
      "parameters": [],
      "responses": {
        "204": {
          "description": "Indicates that the authenticated user successfully started watching this issue.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "401": {
          "description": "When the request wasn't authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the authenticated user is not watching this issue, or when the repo does not exist, or does not have an issue tracker.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue",
            "account:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/issues/export": {
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "A POST request to this endpoint initiates a new background celery task that archives the repo's issues.\n\nFor example, you can run:\n\ncurl -u <username> -X POST http://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/\nissues/export\n\nWhen the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the\n'Location' response header. This url is the endpoint for where the user can obtain their zip files.\"",
      "parameters": [],
      "responses": {
        "202": {
          "description": "The export job has been accepted"
        },
        "401": {
          "description": "The request wasn't authenticated properly",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "When the authenticated user does not have admin permission on the repo",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The repo does not exist or does not have an issue tracker",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin",
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": []
    }
  },
  "/repositories/{username}/{repo_slug}/issues/export/{repo_name}-issues-{task_id}.zip": {
    "get": {
      "description": "This endpoint is used to poll for the progress of an issue export\njob and return the zip file after the job is complete.\nAs long as the job is running, this will return a 200 response\nwith in the response body a description of the current status.\n\nAfter the job has been scheduled, but before it starts executing, this\nendpoint's response is:\n\n{\n \"type\": \"issue_job_status\",\n \"status\": \"ACCEPTED\",\n \"phase\": \"Initializing\",\n \"total\": 0,\n \"count\": 0,\n \"pct\": 0\n}\n\n\nThen once it starts running, it becomes:\n\n{\n \"type\": \"issue_job_status\",\n \"status\": \"STARTED\",\n \"phase\": \"Attachments\",\n \"total\": 15,\n \"count\": 11,\n \"pct\": 73\n}\n\nOnce the job has successfully completed, it returns a stream of the zip file.",
      "parameters": [
        {
          "description": "The name of the repo",
          "in": "path",
          "name": "repo_name",
          "required": true,
          "type": "string"
        },
        {
          "description": "The ID of the export task",
          "in": "path",
          "name": "task_id",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "202": {
          "description": "Export job accepted",
          "schema": {
            "$ref": "#/definitions/issue_job_status"
          }
        },
        "401": {
          "description": "The request wasn't authenticated properly",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "When the authenticated user does not have admin permission on the repo",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "No export job has begun",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin",
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": []
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "repo_name",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "task_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/issues/import": {
    "get": {
      "description": "When using GET, this endpoint reports the status of the current import task. Request example:\n\n```\n$ curl -u <username> -X GET https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import\n```\n\nAfter the job has been scheduled, but before it starts executing, this endpoint's response is:\n\n```\n< HTTP/1.1 202 Accepted\n{\n    \"type\": \"issue_job_status\",\n    \"status\": \"PENDING\",\n    \"phase\": \"Attachments\",\n    \"total\": 15,\n    \"count\": 0,\n    \"percent\": 0\n}\n```\n\nOnce it starts running, it is a 202 response with status STARTED and progress filled.\n\nAfter it is finished, it becomes a 200 response with status SUCCESS or FAILURE.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "Import job complete with either FAILURE or SUCCESS status",
          "schema": {
            "$ref": "#/definitions/issue_job_status"
          }
        },
        "202": {
          "description": "Import job started",
          "schema": {
            "$ref": "#/definitions/issue_job_status"
          }
        },
        "401": {
          "description": "The request wasn't authenticated properly",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "When the authenticated user does not have admin permission on the repo",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "No export job has begun",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin",
            "issue:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": []
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All\nexisting issues will be deleted and replaced by the contents of the imported zip file.\n\nImports are done through a multipart/form-data POST. There is one valid and required form field, with the name\n\"archive,\" which needs to be a file field:\n\n```\n$ curl -u <username> -X POST -F archive=@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import\n```\n\nWhen the import job is accepted, here is example output:\n\n```\n< HTTP/1.1 202 Accepted\n\n{\n    \"type\": \"issue_job_status\",\n    \"status\": \"ACCEPTED\",\n    \"phase\": \"Attachments\",\n    \"total\": 15,\n    \"count\": 0,\n    \"percent\": 0\n}\n```",
      "parameters": [],
      "responses": {
        "202": {
          "description": "Import job accepted",
          "schema": {
            "$ref": "#/definitions/issue_job_status"
          }
        },
        "401": {
          "description": "The request wasn't authenticated properly",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "When the authenticated user does not have admin permission on the repo",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "No export job has begun",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "409": {
          "description": "Import already running",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:admin",
            "issue:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": []
    }
  },
  "/repositories/{username}/{repo_slug}/milestones": {
    "get": {
      "description": "Returns the milestones that have been defined in the issue tracker.\n\nThis resource is only available on repositories that have the issue\ntracker enabled.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The milestones that have been defined in the issue tracker.",
          "schema": {
            "$ref": "#/definitions/paginated_milestones"
          }
        },
        "404": {
          "description": "The specified repository does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/milestones/{milestone_id}": {
    "get": {
      "description": "Returns the specified issue tracker milestone object.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The specified milestone object.",
          "schema": {
            "$ref": "#/definitions/milestone"
          }
        },
        "404": {
          "description": "The specified repository or milestone does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The milestone's id",
        "in": "path",
        "name": "milestone_id",
        "required": true,
        "type": "integer"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/patch/{spec}": {
    "get": {
      "description": "Produces a raw patch for a single commit (diffed against its first\nparent), or a patch-series for a revspec of 2 commits (e.g.\n`3a8b42..9ff173` where the first commit represents the source and the\nsecond commit the destination).\n\nIn case of the latter (diffing a revspec), a patch series is returned\nfor the commits on the source branch (`3a8b42` and its ancestors in\nour example). For Mercurial, a single patch is returned that combines\nthe changes of all commits on the source branch.\n\nWhile similar to diffs, patches:\n\n* Have a commit header (username, commit message, etc)\n* Do not support the `path=foo/bar.py` query parameter\n\nThe raw patch is returned as-is, in whatever encoding the files in the\nrepository use. It is not decoded into unicode. As such, the\ncontent-type is `text/plain`.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The raw patches"
        },
        "555": {
          "description": "If the diff was too large and timed out.\n\nSince this endpoint does not employ any form of pagination, but\ninstead returns the diff as a single document, it can run into\ntrouble on very large diffs. If Bitbucket times out in cases\nlike these, a 555 status code is returned.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "commits"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "spec",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/pullrequests": {
    "get": {
      "description": "Returns all pull requests on the specified repository.\n\nBy default only open pull requests are returned. This can be controlled\nusing the `state` query parameter. To retrieve pull requests that are\nin one of multiple states, repeat the `state` parameter for each\nindividual state.\n\nThis endpoint also supports filtering and sorting of the results. See\n[filtering and sorting](../../../../meta/filtering) for more details.",
      "parameters": [
        {
          "description": "Only return pull requests that are in this state. This parameter can be repeated.",
          "enum": [
            "MERGED",
            "SUPERSEDED",
            "OPEN",
            "DECLINED"
          ],
          "in": "query",
          "name": "state",
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "All pull requests on the specified repository.",
          "schema": {
            "$ref": "#/definitions/paginated_pullrequests"
          }
        },
        "401": {
          "description": "If the repository is private and the request was not authenticated."
        },
        "404": {
          "description": "If the specified repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new pull request where the destination repository is\nthis repository and the author is the authenticated user.\n\nThe minimum required fields to create a pull request are `title` and\n`source`, specified by a branch name.\n\n```\ncurl https://api.bitbucket.org/2.0/repositories/my-username/my-repository/pullrequests \\\n    -u my-username:my-password \\\n    --request POST \\\n    --header 'Content-Type: application/json' \\\n    --data '{\n        \"title\": \"My Title\",\n        \"source\": {\n            \"branch\": {\n                \"name\": \"staging\"\n            }\n        }\n    }'\n```\n\nIf the pull request's `destination` is not specified, it will default\nto the `repository.mainbranch`. To open a pull request to a\ndifferent branch, say from a feature branch to a staging branch,\nspecify a `destination` (same format as the `source`):\n\n```\n{\n    \"title\": \"My Title\",\n    \"source\": {\n        \"branch\": {\n            \"name\": \"my-feature-branch\"\n        }\n    },\n    \"destination\": {\n        \"branch\": {\n            \"name\": \"staging\"\n        }\n    }\n}\n```\n\nReviewers can be specified by adding an array of user objects as the\n`reviewers` property.\n\n```\n{\n    \"title\": \"My Title\",\n    \"source\": {\n        \"branch\": {\n            \"name\": \"my-feature-branch\"\n        }\n    },\n    \"reviewers\": [\n        {\n            \"uuid\": \"{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\"\n        }\n    ]\n}\n```\n\nOther fields:\n\n* `description` - a string\n* `close_source_branch` - boolean that specifies if the source branch should be closed upon merging",
      "parameters": [
        {
          "description": "The new pull request.\n\nThe request URL you POST to becomes the destination repository URL. For this reason, you must specify an explicit source repository in the request object if you want to pull from a different repository (fork).\n\nSince not all elements are required or even mutable, you only need to include the elements you want to initialize, such as the source branch and the title.",
          "in": "body",
          "name": "_body",
          "required": false,
          "schema": {
            "$ref": "#/definitions/pullrequest"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The newly created pull request.",
          "headers": {
            "Location": {
              "description": "The URL of new newly created pull request.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/pullrequest"
          }
        },
        "400": {
          "description": "If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "401": {
          "description": "If the request was not authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}": {
    "get": {
      "description": "Returns the specified pull request.",
      "parameters": [
        {
          "description": "The id of the pull request.",
          "in": "path",
          "name": "pull_request_id",
          "required": true,
          "type": "integer"
        }
      ],
      "responses": {
        "200": {
          "description": "The pull request object",
          "examples": {
            "application/json": {
              "author": {
                "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
                "display_name": "Example Username",
                "links": {
                  "avatar": {
                    "href": "https://bitbucket.org/account/example-username/avatar/"
                  },
                  "html": {
                    "href": "https://bitbucket.org/example-username/"
                  },
                  "self": {
                    "href": "https://api.bitbucket.org/2.0/users/example-username"
                  }
                },
                "nickname": "example-username",
                "type": "user",
                "username": "example-username",
                "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
              },
              "close_source_branch": true,
              "closed_by": null,
              "comment_count": 0,
              "created_on": "2018-06-20T23:17:33.616037+00:00",
              "description": "Everything is awesome!",
              "destination": {
                "branch": {
                  "name": "master"
                },
                "commit": {
                  "hash": "230269fdfabd",
                  "links": {
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs/commits/230269fdfabd"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/230269fdfabd"
                    }
                  },
                  "type": "commit"
                },
                "repository": {
                  "full_name": "example-username/bits_and_bobs",
                  "links": {
                    "avatar": {
                      "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                    },
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                    }
                  },
                  "name": "bits_and_bobs",
                  "type": "repository",
                  "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}"
                }
              },
              "id": 1,
              "links": {
                "activity": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/activity"
                },
                "approve": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/approve"
                },
                "comments": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/comments"
                },
                "commits": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/commits"
                },
                "decline": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/decline"
                },
                "diff": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/diff"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/bits_and_bobs/pull-requests/1"
                },
                "merge": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/merge"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1"
                },
                "statuses": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/statuses"
                }
              },
              "merge_commit": null,
              "participants": [],
              "reason": "",
              "reviewers": [],
              "source": {
                "branch": {
                  "name": "branch_magnificent_internet"
                },
                "commit": {
                  "hash": "c184aab5708b",
                  "links": {
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs/commits/c184aab5708b"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/c184aab5708b"
                    }
                  },
                  "type": "commit"
                },
                "repository": {
                  "full_name": "example-username/bits_and_bobs",
                  "links": {
                    "avatar": {
                      "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                    },
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                    }
                  },
                  "name": "bits_and_bobs",
                  "type": "repository",
                  "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}"
                }
              },
              "state": "OPEN",
              "summary": {
                "html": "<p>Everything is awesome!</p>",
                "markup": "markdown",
                "raw": "Everything is awesome!",
                "type": "rendered"
              },
              "task_count": 0,
              "title": "Change a cooperative standard to a smiling disease",
              "type": "pullrequest",
              "updated_on": "2018-06-20T23:17:33.616037+00:00"
            }
          },
          "schema": {
            "$ref": "#/definitions/pullrequest"
          }
        },
        "401": {
          "description": "If the repository is private and the request was not authenticated."
        },
        "404": {
          "description": "If the repository or pull request does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "pull_request_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Mutates the specified pull request.\n\nThis can be used to change the pull request's branches or description.\n\nOnly open pull requests can be mutated.",
      "parameters": [
        {
          "description": "The id of the pull request.",
          "in": "path",
          "name": "pull_request_id",
          "required": true,
          "type": "integer"
        },
        {
          "description": "The pull request that is to be updated.",
          "in": "body",
          "name": "_body",
          "required": false,
          "schema": {
            "$ref": "#/definitions/pullrequest"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The updated pull request",
          "examples": {
            "application/json": {
              "author": {
                "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
                "display_name": "Example Username",
                "links": {
                  "avatar": {
                    "href": "https://bitbucket.org/account/example-username/avatar/"
                  },
                  "html": {
                    "href": "https://bitbucket.org/example-username/"
                  },
                  "self": {
                    "href": "https://api.bitbucket.org/2.0/users/example-username"
                  }
                },
                "nickname": "example-username",
                "type": "user",
                "username": "example-username",
                "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
              },
              "close_source_branch": true,
              "closed_by": null,
              "comment_count": 0,
              "created_on": "2018-06-20T23:17:33.616037+00:00",
              "description": "Everything is awesome!",
              "destination": {
                "branch": {
                  "name": "master"
                },
                "commit": {
                  "hash": "230269fdfabd",
                  "links": {
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs/commits/230269fdfabd"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/230269fdfabd"
                    }
                  },
                  "type": "commit"
                },
                "repository": {
                  "full_name": "example-username/bits_and_bobs",
                  "links": {
                    "avatar": {
                      "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                    },
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                    }
                  },
                  "name": "bits_and_bobs",
                  "type": "repository",
                  "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}"
                }
              },
              "id": 1,
              "links": {
                "activity": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/activity"
                },
                "approve": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/approve"
                },
                "comments": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/comments"
                },
                "commits": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/commits"
                },
                "decline": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/decline"
                },
                "diff": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/diff"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/bits_and_bobs/pull-requests/1"
                },
                "merge": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/merge"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1"
                },
                "statuses": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/statuses"
                }
              },
              "merge_commit": null,
              "participants": [],
              "reason": "",
              "reviewers": [],
              "source": {
                "branch": {
                  "name": "branch_magnificent_internet"
                },
                "commit": {
                  "hash": "c184aab5708b",
                  "links": {
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs/commits/c184aab5708b"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/c184aab5708b"
                    }
                  },
                  "type": "commit"
                },
                "repository": {
                  "full_name": "example-username/bits_and_bobs",
                  "links": {
                    "avatar": {
                      "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                    },
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                    }
                  },
                  "name": "bits_and_bobs",
                  "type": "repository",
                  "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}"
                }
              },
              "state": "OPEN",
              "summary": {
                "html": "<p>Everything is awesome!</p>",
                "markup": "markdown",
                "raw": "Everything is awesome!",
                "type": "rendered"
              },
              "task_count": 0,
              "title": "Change a cooperative standard to a smiling disease",
              "type": "pullrequest",
              "updated_on": "2018-06-20T23:17:33.616037+00:00"
            }
          },
          "schema": {
            "$ref": "#/definitions/pullrequest"
          }
        },
        "400": {
          "description": "If the input document was invalid.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "401": {
          "description": "If the request was not authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the repository or pull request id does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/activity": {
    "get": {
      "description": "Returns a paginated list of the pull request's activity log.\n\nThis includes comments that were made by the reviewers, updates and\napprovals.\n\nComments created on a file or a line of code have an inline property.\n\nComment example:\n```\n{\n    \"pagelen\": 20,\n    \"values\": [\n        {\n            \"comment\": {\n                \"links\": {\n                    \"self\": {\n                        \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\"\n                    },\n                    \"html\": {\n                        \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\"\n                    }\n                },\n                \"deleted\": false,\n                \"pullrequest\": {\n                    \"type\": \"pullrequest\",\n                    \"id\": 5695,\n                    \"links\": {\n                        \"self\": {\n                            \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"\n                        },\n                        \"html\": {\n                            \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"\n                        }\n                    },\n                    \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"\n                },\n                \"content\": {\n                    \"raw\": \"inline with to a dn from lines\",\n                    \"markup\": \"markdown\",\n                    \"html\": \"<p>inline with to a dn from lines</p>\",\n                    \"type\": \"rendered\"\n                },\n                \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",\n                \"user\": {\n                    \"display_name\": \"Name Lastname\",\n                    \"uuid\": \"{}\",\n                    \"links\": {\n                        \"self\": {\n                            \"href\": \"https://bitbucket.org/!api/2.0/users/%7B%7D\"\n                        },\n                        \"html\": {\n                            \"href\": \"https://bitbucket.org/%7B%7D/\"\n                        },\n                        \"avatar\": {\n                            \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"\n                        }\n                    },\n                    \"type\": \"user\",\n                    \"nickname\": \"Name\",\n                    \"account_id\": \"\"\n                },\n                \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",\n                \"user\": {\n                    \"display_name\": \"Name Lastname\",\n                    \"uuid\": \"{}\",\n                    \"links\": {\n                        \"self\": {\n                            \"href\": \"https://bitbucket.org/!api/2.0/users/%7B%7D\"\n                        },\n                        \"html\": {\n                            \"href\": \"https://bitbucket.org/%7B%7D/\"\n                        },\n                        \"avatar\": {\n                            \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"\n                        }\n                    },\n                    \"type\": \"user\",\n                    \"nickname\": \"Name\",\n                    \"account_id\": \"\"\n                },\n                \"updated_on\": \"2019-09-27T00:33:46.055384+00:00\",\n                \"inline\": {\n                    \"context_lines\": \"\",\n                    \"to\": null,\n                    \"path\": \"\",\n                    \"outdated\": false,\n                    \"from\": 211\n                },\n                \"type\": \"pullrequest_comment\",\n                \"id\": 118571088\n            },\n            \"pull_request\": {\n                \"type\": \"pullrequest\",\n                \"id\": 5695,\n                \"links\": {\n                    \"self\": {\n                        \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"\n                    },\n                    \"html\": {\n                        \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"\n                    }\n                },\n                \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"\n            }\n        }\n    ]\n}\n```\n\nUpdates include a state property of OPEN, MERGED, or DECLINED.\n\nUpdate example:\n```\n{\n    \"pagelen\": 20,\n    \"values\": [\n        {\n            \"update\": {\n                \"description\": \"\",\n                \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\",\n                \"destination\": {\n                    \"commit\": {\n                        \"type\": \"commit\",\n                        \"hash\": \"6a2c16e4a152\",\n                        \"links\": {\n                            \"self\": {\n                                \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\"\n                            },\n                            \"html\": {\n                                \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\"\n                            }\n                        }\n                    },\n                    \"branch\": {\n                        \"name\": \"master\"\n                    },\n                    \"repository\": {\n                        \"name\": \"Atlaskit-MK-2\",\n                        \"type\": \"repository\",\n                        \"full_name\": \"atlassian/atlaskit-mk-2\",\n                        \"links\": {\n                            \"self\": {\n                                \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2\"\n                            },\n                            \"html\": {\n                                \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"\n                            },\n                            \"avatar\": {\n                                \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"\n                            }\n                        },\n                        \"uuid\": \"{}\"\n                    }\n                },\n                \"reason\": \"\",\n                \"source\": {\n                    \"commit\": {\n                        \"type\": \"commit\",\n                        \"hash\": \"728c8bad1813\",\n                        \"links\": {\n                            \"self\": {\n                                \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\"\n                            },\n                            \"html\": {\n                                \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\"\n                            }\n                        }\n                    },\n                    \"branch\": {\n                        \"name\": \"username/NONE-add-onClick-prop-for-accessibility\"\n                    },\n                    \"repository\": {\n                        \"name\": \"Atlaskit-MK-2\",\n                        \"type\": \"repository\",\n                        \"full_name\": \"atlassian/atlaskit-mk-2\",\n                        \"links\": {\n                            \"self\": {\n                                \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2\"\n                            },\n                            \"html\": {\n                                \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"\n                            },\n                            \"avatar\": {\n                                \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"\n                            }\n                        },\n                        \"uuid\": \"{}\"\n                    }\n                },\n                \"state\": \"OPEN\",\n                \"author\": {\n                    \"display_name\": \"Name Lastname\",\n                    \"uuid\": \"{}\",\n                    \"links\": {\n                        \"self\": {\n                            \"href\": \"https://bitbucket.org/!api/2.0/users/%7B%7D\"\n                        },\n                        \"html\": {\n                            \"href\": \"https://bitbucket.org/%7B%7D/\"\n                        },\n                        \"avatar\": {\n                            \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"\n                        }\n                    },\n                    \"type\": \"user\",\n                    \"nickname\": \"Name\",\n                    \"account_id\": \"\"\n                },\n                \"date\": \"2019-05-10T06:48:25.305565+00:00\"\n            },\n            \"pull_request\": {\n                \"type\": \"pullrequest\",\n                \"id\": 5695,\n                \"links\": {\n                    \"self\": {\n                        \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"\n                    },\n                    \"html\": {\n                        \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"\n                    }\n                },\n                \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"\n            }\n        }\n    ]\n}\n```\n\nApproval example:\n```\n{\n    \"pagelen\": 20,\n    \"values\": [\n        {\n            \"approval\": {\n                \"date\": \"2019-09-27T00:37:19.849534+00:00\",\n                \"pullrequest\": {\n                    \"type\": \"pullrequest\",\n                    \"id\": 5695,\n                    \"links\": {\n                        \"self\": {\n                            \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"\n                        },\n                        \"html\": {\n                            \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"\n                        }\n                    },\n                    \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"\n                },\n                \"user\": {\n                    \"display_name\": \"Name Lastname\",\n                    \"uuid\": \"{}\",\n                    \"links\": {\n                        \"self\": {\n                            \"href\": \"https://bitbucket.org/!api/2.0/users/%7B%7D\"\n                        },\n                        \"html\": {\n                            \"href\": \"https://bitbucket.org/%7B%7D/\"\n                        },\n                        \"avatar\": {\n                            \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"\n                        }\n                    },\n                    \"type\": \"user\",\n                    \"nickname\": \"Name\",\n                    \"account_id\": \"\"\n                }\n            },\n            \"pull_request\": {\n                \"type\": \"pullrequest\",\n                \"id\": 5695,\n                \"links\": {\n                    \"self\": {\n                        \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"\n                    },\n                    \"html\": {\n                        \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"\n                    }\n                },\n                \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"\n            }\n        }\n    ]\n}\n```",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The pull request activity log"
        },
        "401": {
          "description": "If the repository is private and the request was not authenticated."
        },
        "404": {
          "description": "If the specified repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The id of the pull request.",
        "in": "path",
        "name": "pull_request_id",
        "required": true,
        "type": "integer"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/approve": {
    "delete": {
      "description": "Redact the authenticated user's approval of the specified pull\nrequest.",
      "parameters": [],
      "responses": {
        "204": {
          "description": "An empty response indicating the authenticated user's approval has been withdrawn."
        },
        "404": {
          "description": "The specified pull request or the repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "pull_request_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Approve the specified pull request as the authenticated user.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The `participant` object recording that the authenticated user approved the pull request.",
          "schema": {
            "$ref": "#/definitions/participant"
          }
        },
        "404": {
          "description": "The specified pull request or the repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/comments": {
    "get": {
      "description": "Returns a paginated list of the pull request's comments.\n\nThis includes both global, inline comments and replies.\n\nThe default sorting is oldest to newest and can be overridden with\nthe `sort` query parameter.\n\nThis endpoint also supports filtering and sorting of the results. See\n[filtering and sorting](../../../../../../meta/filtering) for more\ndetails.",
      "parameters": [
        {
          "description": "The id of the pull request.",
          "in": "path",
          "name": "pull_request_id",
          "required": true,
          "type": "integer"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of comments made on the given pull request, in reverse chronological order.",
          "schema": {
            "$ref": "#/definitions/paginated_pullrequest_comments"
          }
        },
        "403": {
          "description": "If the authenticated user does not have access to the pull request.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the pull request does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "pull_request_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new pull request comment.\n\nReturns the newly created pull request comment.",
      "parameters": [
        {
          "description": "The id of the pull request.",
          "in": "path",
          "name": "pull_request_id",
          "required": true,
          "type": "integer"
        },
        {
          "description": "The comment object.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pullrequest_comment"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The newly created comment.",
          "headers": {
            "Location": {
              "description": "The URL of the new comment",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/pullrequest_comment"
          }
        },
        "403": {
          "description": "If the authenticated user does not have access to the pull request.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the pull request does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}": {
    "delete": {
      "description": "Deletes a specific pull request comment.",
      "parameters": [],
      "responses": {
        "204": {
          "description": "Successful deletion."
        },
        "403": {
          "description": "If the authenticated user does not have access to delete the pull request.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the pull request does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "get": {
      "description": "Returns a specific pull request comment.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The comment.",
          "schema": {
            "$ref": "#/definitions/pullrequest_comment"
          }
        },
        "403": {
          "description": "If the authenticated user does not have access to the pull request.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the pull request does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "pull_request_id",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "comment_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Updates a specific pull request comment.",
      "parameters": [
        {
          "description": "The contents of the updated comment.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pullrequest_comment"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The updated comment.",
          "schema": {
            "$ref": "#/definitions/pullrequest_comment"
          }
        },
        "403": {
          "description": "If the authenticated user does not have access to the pull request.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the pull request does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/commits": {
    "get": {
      "description": "Returns a paginated list of the pull request's commits.\n\nThese are the commits that are being merged into the destination\nbranch when the pull requests gets accepted.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "pull_request_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/decline": {
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "pull_request_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Declines the pull request.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The pull request object.",
          "examples": {
            "application/json": {
              "author": {
                "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
                "display_name": "Example Username",
                "links": {
                  "avatar": {
                    "href": "https://bitbucket.org/account/example-username/avatar/"
                  },
                  "html": {
                    "href": "https://bitbucket.org/example-username/"
                  },
                  "self": {
                    "href": "https://api.bitbucket.org/2.0/users/example-username"
                  }
                },
                "nickname": "example-username",
                "type": "user",
                "username": "example-username",
                "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
              },
              "close_source_branch": true,
              "closed_by": null,
              "comment_count": 0,
              "created_on": "2018-06-20T23:17:33.616037+00:00",
              "description": "Everything is awesome!",
              "destination": {
                "branch": {
                  "name": "master"
                },
                "commit": {
                  "hash": "230269fdfabd",
                  "links": {
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs/commits/230269fdfabd"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/230269fdfabd"
                    }
                  },
                  "type": "commit"
                },
                "repository": {
                  "full_name": "example-username/bits_and_bobs",
                  "links": {
                    "avatar": {
                      "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                    },
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                    }
                  },
                  "name": "bits_and_bobs",
                  "type": "repository",
                  "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}"
                }
              },
              "id": 1,
              "links": {
                "activity": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/activity"
                },
                "approve": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/approve"
                },
                "comments": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/comments"
                },
                "commits": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/commits"
                },
                "decline": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/decline"
                },
                "diff": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/diff"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/bits_and_bobs/pull-requests/1"
                },
                "merge": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/merge"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1"
                },
                "statuses": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/statuses"
                }
              },
              "merge_commit": null,
              "participants": [],
              "reason": "",
              "reviewers": [],
              "source": {
                "branch": {
                  "name": "branch_magnificent_internet"
                },
                "commit": {
                  "hash": "c184aab5708b",
                  "links": {
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs/commits/c184aab5708b"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/c184aab5708b"
                    }
                  },
                  "type": "commit"
                },
                "repository": {
                  "full_name": "example-username/bits_and_bobs",
                  "links": {
                    "avatar": {
                      "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                    },
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                    }
                  },
                  "name": "bits_and_bobs",
                  "type": "repository",
                  "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}"
                }
              },
              "state": "OPEN",
              "summary": {
                "html": "<p>Everything is awesome!</p>",
                "markup": "markdown",
                "raw": "Everything is awesome!",
                "type": "rendered"
              },
              "task_count": 0,
              "title": "Change a cooperative standard to a smiling disease",
              "type": "pullrequest",
              "updated_on": "2018-06-20T23:17:33.616037+00:00"
            }
          },
          "schema": {
            "$ref": "#/definitions/pullrequest"
          }
        },
        "555": {
          "description": "If the decline took too long and timed out.\nIn this case the caller should retry the request later.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/diff": {
    "get": {
      "description": "Redirects to the [repository diff](../../diff/%7Bspec%7D)\nwith the revspec that corresponds to the pull request.",
      "parameters": [],
      "responses": {
        "302": {
          "description": "Redirects to the [repository diff](../../diff/%7Bspec%7D) with the\nrevspec that corresponds to the pull request.\n"
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "pull_request_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/diffstat": {
    "get": {
      "description": "Redirects to the [repository diffstat](../../diffstat/%7Bspec%7D)\nwith the revspec that corresponds to the pull request.",
      "parameters": [],
      "responses": {
        "302": {
          "description": "Redirects to the [repository diffstat](../../diffstat/%7Bspec%7D) with\nthe revspec that corresponds to pull request.\n"
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "pull_request_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/merge": {
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "pull_request_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Merges the pull request.",
      "parameters": [
        {
          "in": "body",
          "name": "_body",
          "required": false,
          "schema": {
            "$ref": "#/definitions/pullrequest_merge_parameters"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The pull request object.",
          "examples": {
            "application/json": {
              "author": {
                "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
                "display_name": "Example Username",
                "links": {
                  "avatar": {
                    "href": "https://bitbucket.org/account/example-username/avatar/"
                  },
                  "html": {
                    "href": "https://bitbucket.org/example-username/"
                  },
                  "self": {
                    "href": "https://api.bitbucket.org/2.0/users/example-username"
                  }
                },
                "nickname": "example-username",
                "type": "user",
                "username": "example-username",
                "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
              },
              "close_source_branch": true,
              "closed_by": null,
              "comment_count": 0,
              "created_on": "2018-06-20T23:17:33.616037+00:00",
              "description": "Everything is awesome!",
              "destination": {
                "branch": {
                  "name": "master"
                },
                "commit": {
                  "hash": "230269fdfabd",
                  "links": {
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs/commits/230269fdfabd"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/230269fdfabd"
                    }
                  },
                  "type": "commit"
                },
                "repository": {
                  "full_name": "example-username/bits_and_bobs",
                  "links": {
                    "avatar": {
                      "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                    },
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                    }
                  },
                  "name": "bits_and_bobs",
                  "type": "repository",
                  "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}"
                }
              },
              "id": 1,
              "links": {
                "activity": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/activity"
                },
                "approve": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/approve"
                },
                "comments": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/comments"
                },
                "commits": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/commits"
                },
                "decline": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/decline"
                },
                "diff": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/diff"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/bits_and_bobs/pull-requests/1"
                },
                "merge": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/merge"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1"
                },
                "statuses": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/pullrequests/1/statuses"
                }
              },
              "merge_commit": null,
              "participants": [],
              "reason": "",
              "reviewers": [],
              "source": {
                "branch": {
                  "name": "branch_magnificent_internet"
                },
                "commit": {
                  "hash": "c184aab5708b",
                  "links": {
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs/commits/c184aab5708b"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/c184aab5708b"
                    }
                  },
                  "type": "commit"
                },
                "repository": {
                  "full_name": "example-username/bits_and_bobs",
                  "links": {
                    "avatar": {
                      "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                    },
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                    }
                  },
                  "name": "bits_and_bobs",
                  "type": "repository",
                  "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}"
                }
              },
              "state": "OPEN",
              "summary": {
                "html": "<p>Everything is awesome!</p>",
                "markup": "markdown",
                "raw": "Everything is awesome!",
                "type": "rendered"
              },
              "task_count": 0,
              "title": "Change a cooperative standard to a smiling disease",
              "type": "pullrequest",
              "updated_on": "2018-06-20T23:17:33.616037+00:00"
            }
          },
          "schema": {
            "$ref": "#/definitions/pullrequest"
          }
        },
        "555": {
          "description": "If the merge took too long and timed out.\nIn this case the caller should retry the request later",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/patch": {
    "get": {
      "description": "",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "pull_request_id",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/statuses": {
    "get": {
      "description": "Returns all statuses (e.g. build results) for the given pull\nrequest.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "A paginated list of all commit statuses for this pull request.",
          "schema": {
            "$ref": "#/definitions/paginated_commitstatuses"
          }
        },
        "401": {
          "description": "If the repository is private and the request was not authenticated."
        },
        "404": {
          "description": "If the specified repository or pull request does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories",
        "pullrequests",
        "commitstatuses"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The id of the pull request.",
        "in": "path",
        "name": "pull_request_id",
        "required": true,
        "type": "integer"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/pullrequests/activity": {
    "get": {
      "description": "Returns a paginated list of the pull request's activity log.\n\nThis includes comments that were made by the reviewers, updates and\napprovals.\n\nComments created on a file or a line of code have an inline property.\n\nComment example:\n```\n{\n    \"pagelen\": 20,\n    \"values\": [\n        {\n            \"comment\": {\n                \"links\": {\n                    \"self\": {\n                        \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\"\n                    },\n                    \"html\": {\n                        \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\"\n                    }\n                },\n                \"deleted\": false,\n                \"pullrequest\": {\n                    \"type\": \"pullrequest\",\n                    \"id\": 5695,\n                    \"links\": {\n                        \"self\": {\n                            \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"\n                        },\n                        \"html\": {\n                            \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"\n                        }\n                    },\n                    \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"\n                },\n                \"content\": {\n                    \"raw\": \"inline with to a dn from lines\",\n                    \"markup\": \"markdown\",\n                    \"html\": \"<p>inline with to a dn from lines</p>\",\n                    \"type\": \"rendered\"\n                },\n                \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",\n                \"user\": {\n                    \"display_name\": \"Name Lastname\",\n                    \"uuid\": \"{}\",\n                    \"links\": {\n                        \"self\": {\n                            \"href\": \"https://bitbucket.org/!api/2.0/users/%7B%7D\"\n                        },\n                        \"html\": {\n                            \"href\": \"https://bitbucket.org/%7B%7D/\"\n                        },\n                        \"avatar\": {\n                            \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"\n                        }\n                    },\n                    \"type\": \"user\",\n                    \"nickname\": \"Name\",\n                    \"account_id\": \"\"\n                },\n                \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",\n                \"user\": {\n                    \"display_name\": \"Name Lastname\",\n                    \"uuid\": \"{}\",\n                    \"links\": {\n                        \"self\": {\n                            \"href\": \"https://bitbucket.org/!api/2.0/users/%7B%7D\"\n                        },\n                        \"html\": {\n                            \"href\": \"https://bitbucket.org/%7B%7D/\"\n                        },\n                        \"avatar\": {\n                            \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"\n                        }\n                    },\n                    \"type\": \"user\",\n                    \"nickname\": \"Name\",\n                    \"account_id\": \"\"\n                },\n                \"updated_on\": \"2019-09-27T00:33:46.055384+00:00\",\n                \"inline\": {\n                    \"context_lines\": \"\",\n                    \"to\": null,\n                    \"path\": \"\",\n                    \"outdated\": false,\n                    \"from\": 211\n                },\n                \"type\": \"pullrequest_comment\",\n                \"id\": 118571088\n            },\n            \"pull_request\": {\n                \"type\": \"pullrequest\",\n                \"id\": 5695,\n                \"links\": {\n                    \"self\": {\n                        \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"\n                    },\n                    \"html\": {\n                        \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"\n                    }\n                },\n                \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"\n            }\n        }\n    ]\n}\n```\n\nUpdates include a state property of OPEN, MERGED, or DECLINED.\n\nUpdate example:\n```\n{\n    \"pagelen\": 20,\n    \"values\": [\n        {\n            \"update\": {\n                \"description\": \"\",\n                \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\",\n                \"destination\": {\n                    \"commit\": {\n                        \"type\": \"commit\",\n                        \"hash\": \"6a2c16e4a152\",\n                        \"links\": {\n                            \"self\": {\n                                \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\"\n                            },\n                            \"html\": {\n                                \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\"\n                            }\n                        }\n                    },\n                    \"branch\": {\n                        \"name\": \"master\"\n                    },\n                    \"repository\": {\n                        \"name\": \"Atlaskit-MK-2\",\n                        \"type\": \"repository\",\n                        \"full_name\": \"atlassian/atlaskit-mk-2\",\n                        \"links\": {\n                            \"self\": {\n                                \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2\"\n                            },\n                            \"html\": {\n                                \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"\n                            },\n                            \"avatar\": {\n                                \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"\n                            }\n                        },\n                        \"uuid\": \"{}\"\n                    }\n                },\n                \"reason\": \"\",\n                \"source\": {\n                    \"commit\": {\n                        \"type\": \"commit\",\n                        \"hash\": \"728c8bad1813\",\n                        \"links\": {\n                            \"self\": {\n                                \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\"\n                            },\n                            \"html\": {\n                                \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\"\n                            }\n                        }\n                    },\n                    \"branch\": {\n                        \"name\": \"username/NONE-add-onClick-prop-for-accessibility\"\n                    },\n                    \"repository\": {\n                        \"name\": \"Atlaskit-MK-2\",\n                        \"type\": \"repository\",\n                        \"full_name\": \"atlassian/atlaskit-mk-2\",\n                        \"links\": {\n                            \"self\": {\n                                \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2\"\n                            },\n                            \"html\": {\n                                \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"\n                            },\n                            \"avatar\": {\n                                \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"\n                            }\n                        },\n                        \"uuid\": \"{}\"\n                    }\n                },\n                \"state\": \"OPEN\",\n                \"author\": {\n                    \"display_name\": \"Name Lastname\",\n                    \"uuid\": \"{}\",\n                    \"links\": {\n                        \"self\": {\n                            \"href\": \"https://bitbucket.org/!api/2.0/users/%7B%7D\"\n                        },\n                        \"html\": {\n                            \"href\": \"https://bitbucket.org/%7B%7D/\"\n                        },\n                        \"avatar\": {\n                            \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"\n                        }\n                    },\n                    \"type\": \"user\",\n                    \"nickname\": \"Name\",\n                    \"account_id\": \"\"\n                },\n                \"date\": \"2019-05-10T06:48:25.305565+00:00\"\n            },\n            \"pull_request\": {\n                \"type\": \"pullrequest\",\n                \"id\": 5695,\n                \"links\": {\n                    \"self\": {\n                        \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"\n                    },\n                    \"html\": {\n                        \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"\n                    }\n                },\n                \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"\n            }\n        }\n    ]\n}\n```\n\nApproval example:\n```\n{\n    \"pagelen\": 20,\n    \"values\": [\n        {\n            \"approval\": {\n                \"date\": \"2019-09-27T00:37:19.849534+00:00\",\n                \"pullrequest\": {\n                    \"type\": \"pullrequest\",\n                    \"id\": 5695,\n                    \"links\": {\n                        \"self\": {\n                            \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"\n                        },\n                        \"html\": {\n                            \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"\n                        }\n                    },\n                    \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"\n                },\n                \"user\": {\n                    \"display_name\": \"Name Lastname\",\n                    \"uuid\": \"{}\",\n                    \"links\": {\n                        \"self\": {\n                            \"href\": \"https://bitbucket.org/!api/2.0/users/%7B%7D\"\n                        },\n                        \"html\": {\n                            \"href\": \"https://bitbucket.org/%7B%7D/\"\n                        },\n                        \"avatar\": {\n                            \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"\n                        }\n                    },\n                    \"type\": \"user\",\n                    \"nickname\": \"Name\",\n                    \"account_id\": \"\"\n                }\n            },\n            \"pull_request\": {\n                \"type\": \"pullrequest\",\n                \"id\": 5695,\n                \"links\": {\n                    \"self\": {\n                        \"href\": \"https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"\n                    },\n                    \"html\": {\n                        \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"\n                    }\n                },\n                \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"\n            }\n        }\n    ]\n}\n```",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The pull request activity log"
        },
        "401": {
          "description": "If the repository is private and the request was not authenticated."
        },
        "404": {
          "description": "If the specified repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "pullrequest"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "pullrequests"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The id of the pull request.",
        "in": "path",
        "name": "pull_request_id",
        "required": true,
        "type": "integer"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/refs": {
    "get": {
      "description": "Returns the branches and tags in the repository.\n\nBy default, results will be in the order the underlying source control system returns them and identical to\nthe ordering one sees when running \"$ git show-ref\". Note that this follows simple\nlexical ordering of the ref names.\n\nThis can be undesirable as it does apply any natural sorting semantics, meaning for instance that refs are\nsorted [\"branch1\", \"branch10\", \"branch2\", \"v10\", \"v11\", \"v9\"] instead of [\"branch1\", \"branch2\",\n\"branch10\", \"v9\", \"v10\", \"v11\"].\n\nSorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name,\nBitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.",
      "parameters": [
        {
          "description": "\nThis can either be the username or the UUID of the user,\nsurrounded by curly-braces, for example: `{user UUID}`.\n",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "\nThis can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "\nQuery string to narrow down the response as per\n[filtering and sorting](../../../../meta/filtering).",
          "in": "query",
          "name": "q",
          "type": "string"
        },
        {
          "description": "\nField by which the results should be sorted as per\n[filtering and sorting](../../../../meta/filtering). The `name`\nfield is handled specially for refs in that, if specified as the sort field, it\nuses a natural sort order instead of the default lexicographical sort order. For example,\nit will return ['1.1', '1.2', '1.10'] instead of ['1.1', '1.10', '1.2'].",
          "in": "query",
          "name": "sort",
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of refs matching any filter criteria that were provided.",
          "schema": {
            "$ref": "#/definitions/paginated_refs"
          }
        },
        "403": {
          "description": "If the repository is private and the authenticated user does not have\naccess to it.\n",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "refs"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/refs/branches": {
    "get": {
      "description": "Returns a list of all open branches within the specified repository.\nResults will be in the order the source control manager returns them.\n\n```\n$ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches | jq .\n{\n  \"pagelen\": 10,\n  \"values\": [\n    {\n      \"heads\": [\n        {\n          \"hash\": \"f1a0933ce59e809f190602655e22ae6ec107c397\",\n          \"type\": \"commit\",\n          \"links\": {\n            \"self\": {\n              \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397\"\n            },\n            \"html\": {\n              \"href\": \"https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397\"\n            }\n          }\n        }\n      ],\n      \"type\": \"named_branch\",\n      \"name\": \"default\",\n      \"links\": {\n        \"commits\": {\n          \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commits/default\"\n        },\n        \"self\": {\n          \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/default\"\n        },\n        \"html\": {\n          \"href\": \"https://bitbucket.org/seanfarley/mercurial/branch/default\"\n        }\n      },\n      \"target\": {\n        \"hash\": \"f1a0933ce59e809f190602655e22ae6ec107c397\",\n        \"repository\": {\n          \"links\": {\n            \"self\": {\n              \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial\"\n            },\n            \"html\": {\n              \"href\": \"https://bitbucket.org/seanfarley/mercurial\"\n            },\n            \"avatar\": {\n              \"href\": \"https://bitbucket.org/seanfarley/mercurial/avatar/32/\"\n            }\n          },\n          \"type\": \"repository\",\n          \"name\": \"mercurial\",\n          \"full_name\": \"seanfarley/mercurial\",\n          \"uuid\": \"{73dcbd61-e506-4fc1-9ecd-31be2b6d6031}\"\n        },\n        \"links\": {\n          \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397\"\n          },\n          \"comments\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/comments\"\n          },\n          \"patch\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/patch/f1a0933ce59e809f190602655e22ae6ec107c397\"\n          },\n          \"html\": {\n            \"href\": \"https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397\"\n          },\n          \"diff\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/diff/f1a0933ce59e809f190602655e22ae6ec107c397\"\n          },\n          \"approve\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/approve\"\n          },\n          \"statuses\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/statuses\"\n          }\n        },\n        \"author\": {\n          \"raw\": \"Martin von Zweigbergk <martinvonz@google.com>\",\n          \"type\": \"author\",\n          \"user\": {\n            \"username\": \"martinvonz\",\n            \"nickname\": \"martinvonz\",\n            \"display_name\": \"Martin von Zweigbergk\",\n            \"type\": \"user\",\n            \"uuid\": \"{fdb0e657-3ade-4fad-a136-95f1ffe4a5ac}\",\n            \"links\": {\n              \"self\": {\n                \"href\": \"https://api.bitbucket.org/2.0/users/martinvonz\"\n              },\n              \"html\": {\n                \"href\": \"https://bitbucket.org/martinvonz/\"\n              },\n              \"avatar\": {\n                \"href\": \"https://bitbucket.org/account/martinvonz/avatar/32/\"\n              }\n            }\n          }\n        },\n        \"parents\": [\n          {\n            \"hash\": \"5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\",\n            \"type\": \"commit\",\n            \"links\": {\n              \"self\": {\n                \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\"\n              },\n              \"html\": {\n                \"href\": \"https://bitbucket.org/seanfarley/mercurial/commits/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\"\n              }\n            }\n          }\n        ],\n        \"date\": \"2018-02-01T18:44:49+00:00\",\n        \"message\": \"config: replace a for-else by any()\",\n        \"type\": \"commit\"\n      }\n    },\n    {\n      \"heads\": [\n        {\n          \"hash\": \"1d60ad093792706e1dc7a52b20942593f2c19655\",\n          \"type\": \"commit\",\n          \"links\": {\n            \"self\": {\n              \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655\"\n            },\n            \"html\": {\n              \"href\": \"https://bitbucket.org/seanfarley/mercurial/commits/1d60ad093792706e1dc7a52b20942593f2c19655\"\n            }\n          }\n        }\n      ],\n      \"type\": \"named_branch\",\n      \"name\": \"stable\",\n      \"links\": {\n        \"commits\": {\n          \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commits/stable\"\n        },\n        \"self\": {\n          \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/stable\"\n        },\n        \"html\": {\n          \"href\": \"https://bitbucket.org/seanfarley/mercurial/branch/stable\"\n        }\n      },\n      \"target\": {\n        \"hash\": \"1d60ad093792706e1dc7a52b20942593f2c19655\",\n        \"repository\": {\n          \"links\": {\n            \"self\": {\n              \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial\"\n            },\n            \"html\": {\n              \"href\": \"https://bitbucket.org/seanfarley/mercurial\"\n            },\n            \"avatar\": {\n              \"href\": \"https://bitbucket.org/seanfarley/mercurial/avatar/32/\"\n            }\n          },\n          \"type\": \"repository\",\n          \"name\": \"mercurial\",\n          \"full_name\": \"seanfarley/mercurial\",\n          \"uuid\": \"{73dcbd61-e506-4fc1-9ecd-31be2b6d6031}\"\n        },\n        \"links\": {\n          \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655\"\n          },\n          \"comments\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655/comments\"\n          },\n          \"patch\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/patch/1d60ad093792706e1dc7a52b20942593f2c19655\"\n          },\n          \"html\": {\n            \"href\": \"https://bitbucket.org/seanfarley/mercurial/commits/1d60ad093792706e1dc7a52b20942593f2c19655\"\n          },\n          \"diff\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/diff/1d60ad093792706e1dc7a52b20942593f2c19655\"\n          },\n          \"approve\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655/approve\"\n          },\n          \"statuses\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655/statuses\"\n          }\n        },\n        \"author\": {\n          \"raw\": \"Augie Fackler <raf@durin42.com>\",\n          \"type\": \"author\",\n          \"user\": {\n            \"username\": \"durin42\",\n            \"nickname\": \"durin42\",\n            \"display_name\": \"Augie Fackler\",\n            \"type\": \"user\",\n            \"uuid\": \"{e07dc61f-bb05-4218-b43a-d991f26be65a}\",\n            \"links\": {\n              \"self\": {\n                \"href\": \"https://api.bitbucket.org/2.0/users/durin42\"\n              },\n              \"html\": {\n                \"href\": \"https://bitbucket.org/durin42/\"\n              },\n              \"avatar\": {\n                \"href\": \"https://bitbucket.org/account/durin42/avatar/32/\"\n              }\n            }\n          }\n        },\n        \"parents\": [\n          {\n            \"hash\": \"56a0da11bde519d79168e890df4bcf0da62f0a7b\",\n            \"type\": \"commit\",\n            \"links\": {\n              \"self\": {\n                \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/56a0da11bde519d79168e890df4bcf0da62f0a7b\"\n              },\n              \"html\": {\n                \"href\": \"https://bitbucket.org/seanfarley/mercurial/commits/56a0da11bde519d79168e890df4bcf0da62f0a7b\"\n              }\n            }\n          }\n        ],\n        \"date\": \"2018-02-01T19:13:41+00:00\",\n        \"message\": \"Added signature for changeset d334afc585e2\",\n        \"type\": \"commit\"\n      }\n    }\n  ],\n  \"page\": 1,\n  \"size\": 2\n}\n```\n\nBranches support [filtering and sorting](../../../../../meta/filtering)\nthat can be used to search for specific branches. For instance, to find\nall branches that have \"stab\" in their name:\n\n```\ncurl -s https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches -G --data-urlencode 'q=name ~ \"stab\"'\n```\n\nBy default, results will be in the order the underlying source control system returns them and identical to\nthe ordering one sees when running \"$ hg branches\" or \"$ git branch --list\". Note that this follows simple\nlexical ordering of the ref names.\n\nThis can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are\nsorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].\n\nSorting can be changed using the ?q= query parameter. When using ?q=name to explicitly sort on ref name,\nBitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.",
      "parameters": [
        {
          "description": "\nThis can either be the username or the UUID of the user,\nsurrounded by curly-braces, for example: `{user UUID}`.\n",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "\nThis can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "\nQuery string to narrow down the response as per\n[filtering and sorting](../../../../../meta/filtering).",
          "in": "query",
          "name": "q",
          "type": "string"
        },
        {
          "description": "\nField by which the results should be sorted as per\n[filtering and sorting](../../../../../meta/filtering). The `name`\nfield is handled specially for branches in that, if specified as the sort field, it\nuses a natural sort order instead of the default lexicographical sort order. For example,\nit will return ['branch1', 'branch2', 'branch10'] instead of ['branch1', 'branch10', 'branch2'].",
          "in": "query",
          "name": "sort",
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of branches matching any filter criteria that were provided.",
          "schema": {
            "$ref": "#/definitions/paginated_branches"
          }
        },
        "403": {
          "description": "If the repository is private and the authenticated user does not have\naccess to it.\n",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "refs"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new branch in the specified repository.\n\nThe payload of the POST should consist of a JSON document that\ncontains the name of the tag and the target hash.\n\n```\ncurl https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/branches \\\n-s -u seanfarley -X POST -H \"Content-Type: application/json\" \\\n-d '{\n    \"name\" : \"smf/create-feature\",\n    \"target\" : {\n        \"hash\" : \"default\",\n    }\n}'\n```\n\nThis call requires authentication. Private repositories require the\ncaller to authenticate with an account that has appropriate\nauthorization.\n\nFor Git, the branch name should not include any prefixes (e.g.\nrefs/heads). This endpoint does support using short hash prefixes for\nthe commit hash, but it may return a 400 response if the provided\nprefix is ambiguous. Using a full commit hash is the preferred\napproach.\n\nFor Mercurial, the authenticated user making this call is the author of\nthe new branch commit and the date is current datetime of the call.",
      "parameters": [],
      "responses": {
        "201": {
          "description": "The newly created branch object.",
          "examples": {
            "application/json": {
              "links": {
                "commits": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commits/master"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/bits_and_bobs/branch/master"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/refs/branches/master"
                }
              },
              "name": "master",
              "target": {
                "author": {
                  "raw": "Example Username <brian_stamm@gmail.com>",
                  "type": "author",
                  "user": {
                    "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
                    "display_name": "Example Username",
                    "links": {
                      "avatar": {
                        "href": "https://bitbucket.org/account/example-username/avatar/"
                      },
                      "html": {
                        "href": "https://bitbucket.org/example-username/"
                      },
                      "self": {
                        "href": "https://api.bitbucket.org/2.0/users/example-username"
                      }
                    },
                    "nickname": "example-username",
                    "type": "user",
                    "username": "example-username",
                    "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
                  }
                },
                "date": "2018-06-20T23:17:33+00:00",
                "hash": "230269fdfabdb5562a991f351b5dd6425de232d2",
                "links": {
                  "approve": {
                    "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/230269fdfabdb5562a991f351b5dd6425de232d2/approve"
                  },
                  "comments": {
                    "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/230269fdfabdb5562a991f351b5dd6425de232d2/comments"
                  },
                  "diff": {
                    "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/diff/230269fdfabdb5562a991f351b5dd6425de232d2"
                  },
                  "html": {
                    "href": "https://bitbucket.org/example-username/bits_and_bobs/commits/230269fdfabdb5562a991f351b5dd6425de232d2"
                  },
                  "patch": {
                    "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/patch/230269fdfabdb5562a991f351b5dd6425de232d2"
                  },
                  "self": {
                    "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/230269fdfabdb5562a991f351b5dd6425de232d2"
                  },
                  "statuses": {
                    "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/230269fdfabdb5562a991f351b5dd6425de232d2/statuses"
                  }
                },
                "message": "Kickass commit message!",
                "parents": [],
                "repository": {
                  "full_name": "example-username/bits_and_bobs",
                  "links": {
                    "avatar": {
                      "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                    },
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                    }
                  },
                  "name": "bits_and_bobs",
                  "type": "repository",
                  "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}"
                },
                "type": "commit"
              },
              "type": "branch"
            }
          },
          "schema": {
            "$ref": "#/definitions/branch"
          }
        },
        "403": {
          "description": "If the repository is private and the authenticated user does not have\naccess to it.\n",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository or branch does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "refs"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/refs/branches/{name}": {
    "delete": {
      "description": "Delete a branch in the specified repository.\n\nThe main branch is not allowed to be deleted and will return a 400\nresponse.\n\nFor Git, the branch name should not include any prefixes (e.g.\nrefs/heads). For Mercurial, this closes all open heads on the branch,\nsets the author of the commit to the authenticated caller, and changes\nthe date to the datetime of the call.",
      "parameters": [],
      "responses": {
        "204": {
          "description": "Indicates that the specified branch was successfully deleted."
        },
        "403": {
          "description": "If the repository is private and the authenticated user does not have\naccess to it.\n",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository or branch does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "refs"
      ]
    },
    "get": {
      "description": "Returns a branch object within the specified repository.\n\n```\n$ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/default | jq .\n{\n  \"heads\": [\n    {\n      \"hash\": \"f1a0933ce59e809f190602655e22ae6ec107c397\",\n      \"type\": \"commit\",\n      \"links\": {\n        \"self\": {\n          \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397\"\n        },\n        \"html\": {\n          \"href\": \"https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397\"\n        }\n      }\n    }\n  ],\n  \"type\": \"named_branch\",\n  \"name\": \"default\",\n  \"links\": {\n    \"commits\": {\n      \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commits/default\"\n    },\n    \"self\": {\n      \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/default\"\n    },\n    \"html\": {\n      \"href\": \"https://bitbucket.org/seanfarley/mercurial/branch/default\"\n    }\n  },\n  \"target\": {\n    \"hash\": \"f1a0933ce59e809f190602655e22ae6ec107c397\",\n    \"repository\": {\n      \"links\": {\n        \"self\": {\n          \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial\"\n        },\n        \"html\": {\n          \"href\": \"https://bitbucket.org/seanfarley/mercurial\"\n        },\n        \"avatar\": {\n          \"href\": \"https://bitbucket.org/seanfarley/mercurial/avatar/32/\"\n        }\n      },\n      \"type\": \"repository\",\n      \"name\": \"mercurial\",\n      \"full_name\": \"seanfarley/mercurial\",\n      \"uuid\": \"{73dcbd61-e506-4fc1-9ecd-31be2b6d6031}\"\n    },\n    \"links\": {\n      \"self\": {\n        \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397\"\n      },\n      \"comments\": {\n        \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/comments\"\n      },\n      \"patch\": {\n        \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/patch/f1a0933ce59e809f190602655e22ae6ec107c397\"\n      },\n      \"html\": {\n        \"href\": \"https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397\"\n      },\n      \"diff\": {\n        \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/diff/f1a0933ce59e809f190602655e22ae6ec107c397\"\n      },\n      \"approve\": {\n        \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/approve\"\n      },\n      \"statuses\": {\n        \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/statuses\"\n      }\n    },\n    \"author\": {\n      \"raw\": \"Martin von Zweigbergk <martinvonz@google.com>\",\n      \"type\": \"author\",\n      \"user\": {\n        \"username\": \"martinvonz\",\n        \"nickname\": \"martinvonz\",\n        \"display_name\": \"Martin von Zweigbergk\",\n        \"type\": \"user\",\n        \"uuid\": \"{fdb0e657-3ade-4fad-a136-95f1ffe4a5ac}\",\n        \"links\": {\n          \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/users/martinvonz\"\n          },\n          \"html\": {\n            \"href\": \"https://bitbucket.org/martinvonz/\"\n          },\n          \"avatar\": {\n            \"href\": \"https://bitbucket.org/account/martinvonz/avatar/32/\"\n          }\n        }\n      }\n    },\n    \"parents\": [\n      {\n        \"hash\": \"5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\",\n        \"type\": \"commit\",\n        \"links\": {\n          \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\"\n          },\n          \"html\": {\n            \"href\": \"https://bitbucket.org/seanfarley/mercurial/commits/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\"\n          }\n        }\n      }\n    ],\n    \"date\": \"2018-02-01T18:44:49+00:00\",\n    \"message\": \"config: replace a for-else by any()\",\n    \"type\": \"commit\"\n  }\n}\n```\n\nThis call requires authentication. Private repositories require the\ncaller to authenticate with an account that has appropriate\nauthorization.\n\nFor Git, the branch name should not include any prefixes (e.g.\nrefs/heads).\n\nFor Mercurial, the response will include an additional field that lists\nthe open heads.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The branch object.",
          "examples": {
            "application/json": {
              "links": {
                "commits": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commits/master"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/bits_and_bobs/branch/master"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/refs/branches/master"
                }
              },
              "name": "master",
              "target": {
                "author": {
                  "raw": "Example Username <brian_stamm@gmail.com>",
                  "type": "author",
                  "user": {
                    "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
                    "display_name": "Example Username",
                    "links": {
                      "avatar": {
                        "href": "https://bitbucket.org/account/example-username/avatar/"
                      },
                      "html": {
                        "href": "https://bitbucket.org/example-username/"
                      },
                      "self": {
                        "href": "https://api.bitbucket.org/2.0/users/example-username"
                      }
                    },
                    "nickname": "example-username",
                    "type": "user",
                    "username": "example-username",
                    "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
                  }
                },
                "date": "2018-06-20T23:17:33+00:00",
                "hash": "230269fdfabdb5562a991f351b5dd6425de232d2",
                "links": {
                  "approve": {
                    "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/230269fdfabdb5562a991f351b5dd6425de232d2/approve"
                  },
                  "comments": {
                    "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/230269fdfabdb5562a991f351b5dd6425de232d2/comments"
                  },
                  "diff": {
                    "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/diff/230269fdfabdb5562a991f351b5dd6425de232d2"
                  },
                  "html": {
                    "href": "https://bitbucket.org/example-username/bits_and_bobs/commits/230269fdfabdb5562a991f351b5dd6425de232d2"
                  },
                  "patch": {
                    "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/patch/230269fdfabdb5562a991f351b5dd6425de232d2"
                  },
                  "self": {
                    "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/230269fdfabdb5562a991f351b5dd6425de232d2"
                  },
                  "statuses": {
                    "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs/commit/230269fdfabdb5562a991f351b5dd6425de232d2/statuses"
                  }
                },
                "message": "Kickass commit message!",
                "parents": [],
                "repository": {
                  "full_name": "example-username/bits_and_bobs",
                  "links": {
                    "avatar": {
                      "href": "https://bytebucket.org/ravatar/%7B7708d810-964c-403f-aa6d-4e949280d614%7D?ts=python"
                    },
                    "html": {
                      "href": "https://bitbucket.org/example-username/bits_and_bobs"
                    },
                    "self": {
                      "href": "https://api.bitbucket.org/2.0/repositories/example-username/bits_and_bobs"
                    }
                  },
                  "name": "bits_and_bobs",
                  "type": "repository",
                  "uuid": "{7708d810-964c-403f-aa6d-4e949280d614}"
                },
                "type": "commit"
              },
              "type": "branch"
            }
          },
          "schema": {
            "$ref": "#/definitions/branch"
          }
        },
        "403": {
          "description": "If the repository is private and the authenticated user does not have\naccess to it.\n",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository or branch does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "refs"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The name of the branch.",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/refs/tags": {
    "get": {
      "description": "Returns the tags in the repository.\n\nBy default, results will be in the order the underlying source control system returns them and identical to\nthe ordering one sees when running \"$ hg tags\" or \"$ git tag --list\". Note that this follows simple\nlexical ordering of the ref names.\n\nThis can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are\nsorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].\n\nSorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name,\nBitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.",
      "parameters": [
        {
          "description": "\nThis can either be the username or the UUID of the user,\nsurrounded by curly-braces, for example: `{user UUID}`.\n",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "\nThis can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "\nQuery string to narrow down the response as per\n[filtering and sorting](../../../../../meta/filtering).",
          "in": "query",
          "name": "q",
          "type": "string"
        },
        {
          "description": "\nField by which the results should be sorted as per\n[filtering and sorting](../../../../../meta/filtering). The `name`\nfield is handled specially for tags in that, if specified as the sort field, it\nuses a natural sort order instead of the default lexicographical sort order. For example,\nit will return ['1.1', '1.2', '1.10'] instead of ['1.1', '1.10', '1.2'].",
          "in": "query",
          "name": "sort",
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of tags matching any filter criteria that were provided.",
          "schema": {
            "$ref": "#/definitions/paginated_tags"
          }
        },
        "403": {
          "description": "If the repository is private and the authenticated user does not have\naccess to it.\n",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "refs"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new tag in the specified repository.\n\nThe payload of the POST should consist of a JSON document that\ncontains the name of the tag and the target hash.\n\n```\ncurl https://api.bitbucket.org/2.0/repositories/jdoe/myrepo/refs/tags \\\n-s -u jdoe -X POST -H \"Content-Type: application/json\" \\\n-d '{\n    \"name\" : \"new-tag-name\",\n    \"target\" : {\n        \"hash\" : \"a1b2c3d4e5f6\",\n    }\n}'\n```\n\nThis endpoint does support using short hash prefixes for the commit\nhash, but it may return a 400 response if the provided prefix is\nambiguous. Using a full commit hash is the preferred approach.",
      "parameters": [
        {
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/tag"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The newly created tag.",
          "schema": {
            "$ref": "#/definitions/tag"
          }
        },
        "400": {
          "description": "If the target hash is missing, ambiguous, or invalid, or if the name is not provided.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "refs"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/refs/tags/{name}": {
    "delete": {
      "description": "Delete a tag in the specified repository.\n\nFor Git, the tag name should not include any prefixes (e.g. refs/tags).\nFor Mercurial, this adds a commit to the main branch that removes the\nspecified tag.",
      "parameters": [],
      "responses": {
        "204": {
          "description": "Indicates the specified tag was successfully deleted."
        },
        "403": {
          "description": "If the repository is private and the authenticated user does not have\naccess to it.\n",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository or tag does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "refs"
      ]
    },
    "get": {
      "description": "Returns the specified tag.\n\n```\n$ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8 -G | jq .\n{\n  \"name\": \"3.8\",\n  \"links\": {\n    \"commits\": {\n      \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commits/3.8\"\n    },\n    \"self\": {\n      \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8\"\n    },\n    \"html\": {\n      \"href\": \"https://bitbucket.org/seanfarley/hg/commits/tag/3.8\"\n    }\n  },\n  \"tagger\": {\n    \"raw\": \"Matt Mackall <mpm@selenic.com>\",\n    \"type\": \"author\",\n    \"user\": {\n      \"username\": \"mpmselenic\",\n      \"nickname\": \"mpmselenic\",\n      \"display_name\": \"Matt Mackall\",\n      \"type\": \"user\",\n      \"uuid\": \"{a4934530-db4c-419c-a478-9ab4964c2ee7}\",\n      \"links\": {\n        \"self\": {\n          \"href\": \"https://api.bitbucket.org/2.0/users/mpmselenic\"\n        },\n        \"html\": {\n          \"href\": \"https://bitbucket.org/mpmselenic/\"\n        },\n        \"avatar\": {\n          \"href\": \"https://bitbucket.org/account/mpmselenic/avatar/32/\"\n        }\n      }\n    }\n  },\n  \"date\": \"2016-05-01T18:52:25+00:00\",\n  \"message\": \"Added tag 3.8 for changeset f85de28eae32\",\n  \"type\": \"tag\",\n  \"target\": {\n    \"hash\": \"f85de28eae32e7d3064b1a1321309071bbaaa069\",\n    \"repository\": {\n      \"links\": {\n        \"self\": {\n          \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg\"\n        },\n        \"html\": {\n          \"href\": \"https://bitbucket.org/seanfarley/hg\"\n        },\n        \"avatar\": {\n          \"href\": \"https://bitbucket.org/seanfarley/hg/avatar/32/\"\n        }\n      },\n      \"type\": \"repository\",\n      \"name\": \"hg\",\n      \"full_name\": \"seanfarley/hg\",\n      \"uuid\": \"{c75687fb-e99d-4579-9087-190dbd406d30}\"\n    },\n    \"links\": {\n      \"self\": {\n        \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069\"\n      },\n      \"comments\": {\n        \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/comments\"\n      },\n      \"patch\": {\n        \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/patch/f85de28eae32e7d3064b1a1321309071bbaaa069\"\n      },\n      \"html\": {\n        \"href\": \"https://bitbucket.org/seanfarley/hg/commits/f85de28eae32e7d3064b1a1321309071bbaaa069\"\n      },\n      \"diff\": {\n        \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/diff/f85de28eae32e7d3064b1a1321309071bbaaa069\"\n      },\n      \"approve\": {\n        \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/approve\"\n      },\n      \"statuses\": {\n        \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/statuses\"\n      }\n    },\n    \"author\": {\n      \"raw\": \"Sean Farley <sean@farley.io>\",\n      \"type\": \"author\",\n      \"user\": {\n        \"username\": \"seanfarley\",\n        \"nickname\": \"seanfarley\",\n        \"display_name\": \"Sean Farley\",\n        \"type\": \"user\",\n        \"uuid\": \"{a295f8a8-5876-4d43-89b5-3ad8c6c3c51d}\",\n        \"links\": {\n          \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/users/seanfarley\"\n          },\n          \"html\": {\n            \"href\": \"https://bitbucket.org/seanfarley/\"\n          },\n          \"avatar\": {\n            \"href\": \"https://bitbucket.org/account/seanfarley/avatar/32/\"\n          }\n        }\n      }\n    },\n    \"parents\": [\n      {\n        \"hash\": \"9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\",\n        \"type\": \"commit\",\n        \"links\": {\n          \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"\n          },\n          \"html\": {\n            \"href\": \"https://bitbucket.org/seanfarley/hg/commits/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"\n          }\n        }\n      }\n    ],\n    \"date\": \"2016-05-01T04:21:17+00:00\",\n    \"message\": \"debian: alphabetize build deps\",\n    \"type\": \"commit\"\n  }\n}\n```",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The tag object.",
          "schema": {
            "$ref": "#/definitions/tag"
          }
        },
        "403": {
          "description": "If the repository is private and the authenticated user does not have\naccess to it.\n",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The specified repository or tag does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "refs"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The name of the tag.",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/src": {
    "get": {
      "description": "This endpoint redirects the client to the directory listing of the\nroot directory on the main branch.\n\nThis is equivalent to directly hitting\n[/2.0/repositories/{username}/{repo_slug}/src/{node}/{path}](src/%7Bnode%7D/%7Bpath%7D)\nwithout having to know the name or SHA1 of the repo's main branch.\n\nTo create new commits, [POST to this endpoint](#post)",
      "parameters": [
        {
          "description": "Instead of returning the file's contents, return the (json) meta data for it.",
          "enum": [
            "meta"
          ],
          "in": "query",
          "name": "format",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "If the path matches a file, then the raw contents of the file are\nreturned (unless the `format=meta` query parameter was provided,\nin which case a json document containing the file's meta data is\nreturned). If the path matches a directory, then a paginated\nlist of file and directory entries is returned (if the\n`format=meta` query parameter was provided, then the json document\ncontaining the directory's meta data is returned).\n",
          "schema": {
            "$ref": "#/definitions/paginated_treeentries"
          }
        },
        "404": {
          "description": "If the path or commit in the URL does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "source",
        "repositories"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "This endpoint is used to create new commits in the repository by\nuploading files.\n\nTo add a new file to a repository:\n\n```\n$ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\\n  -F /repo/path/to/image.png=@image.png\n```\n\nThis will create a new commit on top of the main branch, inheriting the\ncontents of the main branch, but adding (or overwriting) the\n`image.png` file to the repository in the `/repo/path/to` directory.\n\nTo create a commit that deletes files, use the `files` parameter:\n\n```\n$ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\\n  -F files=/file/to/delete/1.txt \\\n  -F files=/file/to/delete/2.txt\n```\n\nYou can add/modify/delete multiple files in a request. Rename/move a\nfile by deleting the old path and adding the content at the new path.\n\nThis endpoint accepts `multipart/form-data` (as in the examples above),\nas well as `application/x-www-form-urlencoded`.\n\n## multipart/form-data\n\nA `multipart/form-data` post contains a series of \"form fields\" that\nidentify both the individual files that are being uploaded, as well as\nadditional, optional meta data.\n\nFiles are uploaded in file form fields (those that have a\n`Content-Disposition` parameter) whose field names point to the remote\npath in the repository where the file should be stored. Path field\nnames are always interpreted to be absolute from the root of the\nrepository, regardless whether the client uses a leading slash (as the\nabove `curl` example did).\n\nFile contents are treated as bytes and are not decoded as text.\n\nThe commit message, as well as other non-file meta data for the\nrequest, is sent along as normal form field elements. Meta data fields\nshare the same namespace as the file objects. For `multipart/form-data`\nbodies that should not lead to any ambiguity, as the\n`Content-Disposition` header will contain the `filename` parameter to\ndistinguish between a file named \"message\" and the commit message field.\n\n## application/x-www-form-urlencoded\n\nIt is also possible to upload new files using a simple\n`application/x-www-form-urlencoded` POST. This can be convenient when\nuploading pure text files:\n\n```\n$ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\\n  --data-urlencode \"/path/to/me.txt=Lorem ipsum.\" \\\n  --data-urlencode \"message=Initial commit\" \\\n  --data-urlencode \"author=Erik van Zijst <erik.van.zijst@gmail.com>\"\n```\n\nThere could be a field name clash if a client were to upload a file\nnamed \"message\", as this filename clashes with the meta data property\nfor the commit message. To avoid this and to upload files whose names\nclash with the meta data properties, use a leading slash for the files,\ne.g. `curl --data-urlencode \"/message=file contents\"`.\n\nWhen an explicit slash is omitted for a file whose path matches that of\na meta data parameter, then it is interpreted as meta data, not as a\nfile.\n\n## Executables and links\n\nWhile this API aims to facilitate the most common use cases, it is\npossible to perform some more advanced operations like creating a new\nsymlink in the repository, or creating an executable file.\n\nFiles can be supplied with a `x-attributes` value in the\n`Content-Disposition` header. For example, to upload an executable\nfile, as well as create a symlink from `README.txt` to `README`:\n\n```\n--===============1438169132528273974==\nContent-Type: text/plain; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 7bit\nContent-ID: \"bin/shutdown.sh\"\nContent-Disposition: attachment; filename=\"shutdown.sh\"; x-attributes:\"executable\"\n\n#!/bin/sh\nhalt\n\n--===============1438169132528273974==\nContent-Type: text/plain; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 7bit\nContent-ID: \"/README.txt\"\nContent-Disposition: attachment; filename=\"README.txt\"; x-attributes:\"link\"\n\nREADME\n--===============1438169132528273974==--\n```\n\nLinks are files that contain the target path and have\n`x-attributes:\"link\"` set.\n\nWhen overwriting links with files, or vice versa, the newly uploaded\nfile determines both the new contents, as well as the attributes. That\nmeans uploading a file without specifying `x-attributes=\"link\"` will\ncreate a regular file, even if the parent commit hosted a symlink at\nthe same path.\n\nThe same applies to executables. When modifying an existing executable\nfile, the form-data file element must include\n`x-attributes=\"executable\"` in order to preserve the executable status\nof the file.\n\nNote that this API does not support the creation or manipulation of\nsubrepos / submodules.",
      "parameters": [
        {
          "description": "The commit message. When omitted, Bitbucket uses a canned string.",
          "in": "query",
          "name": "message",
          "required": false,
          "type": "string"
        },
        {
          "description": "\nThe raw string to be used as the new commit's author.\nThis string follows the format\n`Erik van Zijst <evzijst@atlassian.com>`.\n\nWhen omitted, Bitbucket uses the authenticated user's\nfull/display name and primary email address. Commits cannot\nbe created anonymously.",
          "in": "query",
          "name": "author",
          "required": false,
          "type": "string"
        },
        {
          "description": "\nA comma-separated list of SHA1s of the commits that should\nbe the parents of the newly created commit.\n\nWhen omitted, the new commit will inherit from and become\na child of the main branch's tip/HEAD commit.\n\nWhen more than one SHA1 is provided, the first SHA1\nidentifies the commit from which the content will be\ninherited.\n\nWhen more than 2 parents are provided on a Mercurial repo,\na 400 is returned as Mercurial does not support \"octopus\nmerges\".",
          "in": "query",
          "name": "parents",
          "required": false,
          "type": "string"
        },
        {
          "description": "\nOptional field that declares the files that the request is\nmanipulating. When adding a new file to a repo, or when\noverwriting an existing file, the client can just upload\nthe full contents of the file in a normal form field and\nthe use of this `files` meta data field is redundant.\nHowever, when the `files` field contains a file path that\ndoes not have a corresponding, identically-named form\nfield, then Bitbucket interprets that as the client wanting\nto replace the named file with the null set and the file is\ndeleted instead.\n\nPaths in the repo that are referenced in neither files nor\nan individual file field, remain unchanged and carry over\nfrom the parent to the new commit.\n\nThis API does not support renaming as an explicit feature.\nTo rename a file, simply delete it and recreate it under\nthe new name in the same commit.\n",
          "in": "query",
          "name": "files",
          "required": false,
          "type": "string"
        },
        {
          "description": "\nThe name of the branch that the new commit should be\ncreated on. When omitted, the commit will be created on top\nof the main branch and will become the main branch's new\nHEAD/tip.\n\nWhen a branch name is provided that already exists in the\nrepo, then the commit will be created on top of that\nbranch. In this case, if a parent SHA1 was also provided,\nthen it is asserted that the parent is the branch's\ntip/HEAD at the time the request is made. When this is not\nthe case, a 409 is returned.\n\nThis API cannot be used to create new anonymous heads in\nMercurial repos.\n\nWhen a new branch name is specified (that does not already\nexist in the repo), and no parent SHA1s are provided, then\nthe new commit will inherit from the current main branch's\ntip/HEAD commit, but not advance the main branch. The new\ncommit will be the new branch. When the request also\nspecifies a parent SHA1, then the new commit and branch\nare created directly on top of the parent commit,\nregardless of the state of the main branch.\n\nWhen a branch name is not specified, but a parent SHA1 is\nprovided, then Bitbucket asserts that it represents the\nmain branch's current HEAD/tip, or a 409 is returned.\n\nWhen a branch name is not specified and the repo is empty,\nthe new commit will become the repo's root commit and will\nbe on the main branch.\n\nWhen a branch name is specified and the repo is empty, the\nnew commit will become the repo's root commit and also\ndefine the repo's main branch going forward.\n\nThis API cannot be used to create additional root commits\nin non-empty repos.\n\nThe branch field cannot be repeated.\n\nAs a side effect, this API can be used to create a new\nbranch without modifying any files, by specifying a new\nbranch name in this field, together with parents, but\nomitting the files fields, while not sending any files.\nThis will create a new commit and branch with the same\ncontents as the first parent. The diff of this commit\nagainst its first parent will be empty.\n",
          "in": "query",
          "name": "files",
          "required": false,
          "type": "string"
        },
        {
          "description": "\nThe name of the branch that the new commit should be\ncreated on. When omitted, the commit will be created on top\nof the main branch and will become the main branch's new\nhead.\n\nWhen a branch name is provided that already exists in the\nrepo, then the commit will be created on top of that\nbranch. In this case, *if* a parent SHA1 was also provided,\nthen it is asserted that the parent is the branch's\ntip/HEAD at the time the request is made. When this is not\nthe case, a 409 is returned.\n\nThis API cannot be used to create new anonymous heads in\nMercurial repositories.\n\nWhen a new branch name is specified (that does not already\nexist in the repo), and no parent SHA1s are provided, then\nthe new commit will inherit from the current main branch's\ntip/HEAD commit, but not advance the main branch. The new\ncommit will be the new branch. When the request *also*\nspecifies a parent SHA1, then the new commit and branch\nare created directly on top of the parent commit,\nregardless of the state of the main branch.\n\nWhen a branch name is not specified, but a parent SHA1 is\nprovided, then Bitbucket asserts that it represents the\nmain branch's current HEAD/tip, or a 409 is returned.\n\nWhen a branch name is not specified and the repo is empty,\nthe new commit will become the repo's root commit and will\nbe on the main branch.\n\nWhen a branch name is specified and the repo is empty, the\nnew commit will become the repo's root commit and also\ndefine the repo's main branch going forward.\n\nThis API cannot be used to create additional root commits\nin non-empty repos.\n\nThe branch field cannot be repeated.\n\nAs a side effect, this API can be used to create a new\nbranch without modifying any files, by specifying a new\nbranch name in this field, together with `parents`, but\nomitting the `files` fields, while not sending any files.\nThis will create a new commit and branch with the same\ncontents as the first parent. The diff of this commit\nagainst its first parent will be empty.\n",
          "in": "query",
          "name": "branch",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "\n"
        },
        "404": {
          "description": "If the repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "source",
        "repositories"
      ]
    }
  },
  "/repositories/{username}/{repo_slug}/src/{node}/{path}": {
    "get": {
      "description": "This endpoints is used to retrieve the contents of a single file,\nor the contents of a directory at a specified revision.\n\n## Raw file contents\n\nWhen `path` points to a file, this endpoint returns the raw contents.\nThe response's Content-Type is derived from the filename\nextension (not from the contents). The file contents are not processed\nand no character encoding/recoding is performed and as a result no\ncharacter encoding is included as part of the Content-Type.\n\nThe `Content-Disposition` header will be \"attachment\" to prevent\nbrowsers from running executable files.\n\nIf the file is managed by LFS, then a 301 redirect pointing to\nAtlassian's media services platform is returned.\n\nThe response includes an ETag that is based on the contents of the file\nand its attributes. This means that an empty `__init__.py` always\nreturns the same ETag, regardless on the directory it lives in, or the\ncommit it is on.\n\n## File meta data\n\nWhen the request for a file path includes the query parameter\n`?format=meta`, instead of returning the file's raw contents, Bitbucket\ninstead returns the JSON object describing the file's properties:\n\n```javascript\n$ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta\n{\n  \"links\": {\n    \"self\": {\n      \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"\n    },\n    \"meta\": {\n      \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"\n    }\n  },\n  \"path\": \"tests/__init__.py\",\n  \"commit\": {\n    \"type\": \"commit\",\n    \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",\n    \"links\": {\n      \"self\": {\n        \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"\n      },\n      \"html\": {\n        \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"\n      }\n    }\n  },\n  \"attributes\": [],\n  \"type\": \"commit_file\",\n  \"size\": 0\n}\n```\n\nFile objects contain an `attributes` element that contains a list of\npossible modifiers. Currently defined values are:\n\n* `link` -- indicates that the entry is a symbolic link. The contents\n    of the file represent the path the link points to.\n* `executable` -- indicates that the file has the executable bit set.\n* `subrepository` -- indicates that the entry points to a submodule or\n    subrepo. The contents of the file is the SHA1 of the repository\n    pointed to.\n* `binary` -- indicates whether Bitbucket thinks the file is binary.\n\nThis endpoint can provide an alternative to how a HEAD request can be\nused to check for the existence of a file, or a file's size without\nincurring the overhead of receiving its full contents.\n\n\n## Directory listings\n\nWhen `path` points to a directory instead of a file, the response is a\npaginated list of directory and file objects in the same order as the\nunderlying SCM system would return them.\n\nFor example:\n\n```javascript\n$ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests\n{\n  \"pagelen\": 10,\n  \"values\": [\n    {\n      \"path\": \"tests/test_project\",\n      \"type\": \"commit_directory\",\n      \"links\": {\n        \"self\": {\n          \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"\n        },\n        \"meta\": {\n          \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"\n        }\n      },\n      \"commit\": {\n        \"type\": \"commit\",\n        \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",\n        \"links\": {\n          \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"\n          },\n          \"html\": {\n            \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"\n          }\n        }\n      }\n    },\n    {\n      \"links\": {\n        \"self\": {\n          \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"\n        },\n        \"meta\": {\n          \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"\n        }\n      },\n      \"path\": \"tests/__init__.py\",\n      \"commit\": {\n        \"type\": \"commit\",\n        \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",\n        \"links\": {\n          \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"\n          },\n          \"html\": {\n            \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"\n          }\n        }\n      },\n      \"attributes\": [],\n      \"type\": \"commit_file\",\n      \"size\": 0\n    }\n  ],\n  \"page\": 1,\n  \"size\": 2\n}\n```\n\nWhen listing the contents of the repo's root directory, the use of a\ntrailing slash at the end of the URL is required.\n\nThe response by default is not recursive, meaning that only the direct contents of\na path are returned. The response does not recurse down into\nsubdirectories. In order to \"walk\" the entire directory tree, the\nclient can either parse each response and follow the `self` links of each\n`commit_directory` object, or can specify a `max_depth` to recurse to.\n\nThe max_depth parameter will do a breadth-first search to return the contents of the subdirectories\nup to the depth specified. Breadth-first search was chosen as it leads to the least amount of\nfile system operations for git. If the `max_depth` parameter is specified to be too\nlarge, the call will time out and return a 555.\n\nEach returned object is either a `commit_file`, or a `commit_directory`,\nboth of which contain a `path` element. This path is the absolute path\nfrom the root of the repository. Each object also contains a `commit`\nobject which embeds the commit the file is on. Note that this is merely\nthe commit that was used in the URL. It is *not* the commit that last\nmodified the file.\n\nDirectory objects have 2 representations. Their `self` link returns the\npaginated contents of the directory. The `meta` link on the other hand\nreturns the actual `directory` object itself, e.g.:\n\n```javascript\n{\n  \"path\": \"tests/test_project\",\n  \"type\": \"commit_directory\",\n  \"links\": {\n    \"self\": {\n      \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"\n    },\n    \"meta\": {\n      \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"\n    }\n  },\n  \"commit\": { ... }\n}\n```\n\n## Querying, filtering and sorting\n\nLike most API endpoints, this API supports the Bitbucket\nquerying/filtering syntax and so you could filter a directory listing\nto only include entries that match certain criteria. For instance, to\nlist all binary files over 1kb use the expression:\n\n`size > 1024 and attributes = \"binary\"`\n\nwhich after urlencoding yields the query string:\n\n`?q=size%3E1024+and+attributes%3D%22binary%22`\n\nTo change the ordering of the response, use the `?sort` parameter:\n\n`.../src/eefd5ef/?sort=-size`\n\nSee [filtering and sorting](../../../../../../meta/filtering) for more\ndetails.",
      "parameters": [
        {
          "description": "If 'meta' is provided, returns the (json) meta data for the contents of the file.  If 'rendered' is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. Since Git and Mercurial do not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file's actual contents.",
          "enum": [
            "meta",
            "rendered"
          ],
          "in": "query",
          "name": "format",
          "required": false,
          "type": "string"
        },
        {
          "description": "Optional filter expression as per [filtering and sorting](../../../../../../meta/filtering).",
          "in": "query",
          "name": "q",
          "required": false,
          "type": "string"
        },
        {
          "description": "Optional sorting parameter as per [filtering and sorting](../../../../../../meta/filtering#query-sort).",
          "in": "query",
          "name": "sort",
          "required": false,
          "type": "string"
        },
        {
          "description": "If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1.",
          "in": "query",
          "name": "max_depth",
          "required": false,
          "type": "integer"
        }
      ],
      "responses": {
        "200": {
          "description": "If the path matches a file, then the raw contents of the file are\nreturned.  If the `format=meta` query parameter is provided,\na json document containing the file's meta data is\nreturned.  If the `format=rendered` query parameter is provided,\nthe contents of the file in HTML-formated rendered markup is returned.\nIf the path matches a directory, then a paginated\nlist of file and directory entries is returned (if the\n`format=meta` query parameter was provided, then the json document\ncontaining the directory's meta data is returned.)\n",
          "schema": {
            "$ref": "#/definitions/paginated_treeentries"
          }
        },
        "404": {
          "description": "If the path or commit in the URL does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "555": {
          "description": "If the call times out, possibly because the specifiedrecursion depth is too large.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "source",
        "repositories"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "node",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "path",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/versions": {
    "get": {
      "description": "Returns the versions that have been defined in the issue tracker.\n\nThis resource is only available on repositories that have the issue\ntracker enabled.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The versions that have been defined in the issue tracker.",
          "schema": {
            "$ref": "#/definitions/paginated_versions"
          }
        },
        "404": {
          "description": "The specified repository does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/versions/{version_id}": {
    "get": {
      "description": "Returns the specified issue tracker version object.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The specified version object.",
          "schema": {
            "$ref": "#/definitions/version"
          }
        },
        "404": {
          "description": "The specified repository or version does not exist or does not have the issue tracker enabled.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "issue"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "issue_tracker"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The version's id",
        "in": "path",
        "name": "version_id",
        "required": true,
        "type": "integer"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{username}/{repo_slug}/watchers": {
    "get": {
      "description": "Returns a paginated list of all the watchers on the specified\nrepository.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "A paginated list of all the watchers on the specified repository."
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/repositories/{workspace}/{repo_slug}/commit/{commit}/properties/{app_key}/{property_name}": {
    "delete": {
      "description": "Delete an application property value stored against a commit.",
      "operationId": "deleteCommitHostedPropertyValue",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The commit.",
          "in": "path",
          "name": "commit",
          "required": true,
          "type": "string"
        },
        {
          "description": "The key of the Connect app.",
          "in": "path",
          "name": "app_key",
          "required": true,
          "type": "string"
        },
        {
          "description": "The name of the property.",
          "in": "path",
          "name": "property_name",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "An empty response."
        }
      },
      "tags": [
        "properties"
      ]
    },
    "get": {
      "description": "Retrieve an application property value stored against a commit.",
      "operationId": "getCommitHostedPropertyValue",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The commit.",
          "in": "path",
          "name": "commit",
          "required": true,
          "type": "string"
        },
        {
          "description": "The key of the Connect app.",
          "in": "path",
          "name": "app_key",
          "required": true,
          "type": "string"
        },
        {
          "description": "The name of the property.",
          "in": "path",
          "name": "property_name",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The value of the property."
        }
      },
      "tags": [
        "properties"
      ]
    },
    "put": {
      "description": "Update an application property value stored against a commit.",
      "operationId": "updateCommitHostedPropertyValue",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The commit.",
          "in": "path",
          "name": "commit",
          "required": true,
          "type": "string"
        },
        {
          "description": "The key of the Connect app.",
          "in": "path",
          "name": "app_key",
          "required": true,
          "type": "string"
        },
        {
          "description": "The name of the property.",
          "in": "path",
          "name": "property_name",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "An empty response."
        }
      },
      "tags": [
        "properties"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/commit/{commit}/pullrequests": {
    "get": {
      "operationId": "getPullrequestsForCommit",
      "parameters": [
        {
          "description": "The account; either the UUID in curly braces, or the account_id",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository; either the UUID in curly braces, or the slug",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The SHA1 of the commit",
          "in": "path",
          "name": "commit",
          "required": true,
          "type": "string"
        },
        {
          "default": 1,
          "description": "Which page to retrieve",
          "format": "int32",
          "in": "query",
          "name": "page",
          "required": false,
          "type": "integer"
        },
        {
          "default": 30,
          "description": "How many pull requests to retrieve per page",
          "format": "int32",
          "in": "query",
          "name": "pagelen",
          "required": false,
          "type": "integer"
        }
      ],
      "produces": [
        "application/json"
      ],
      "responses": {
        "200": {
          "description": "The paginated list of pull requests.",
          "schema": {
            "$ref": "#/definitions/paginated_pullrequests"
          }
        },
        "202": {
          "description": "The repository's pull requests are still being indexed.",
          "schema": {
            "$ref": "#/definitions/paginated_pullrequests"
          }
        },
        "404": {
          "description": "Either the repository does not exist, or pull request commit links have not yet been indexed.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "summary": "Returns a paginated list of all pull requests as part of which this commit was reviewed.",
      "tags": [
        "pullrequests"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables": {
    "get": {
      "description": "Find deployment environment level variables.",
      "operationId": "getDeploymentVariables",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The environment.",
          "in": "path",
          "name": "environment_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The retrieved deployment variables.",
          "schema": {
            "$ref": "#/definitions/paginated_deployment_variable"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "post": {
      "description": "Create a deployment environment level variable.",
      "operationId": "createDeploymentVariable",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The environment.",
          "in": "path",
          "name": "environment_uuid",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the variable to update.",
          "in": "path",
          "name": "variable_uuid",
          "required": true,
          "type": "string"
        },
        {
          "description": "The variable to create",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/deployment_variable"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The variable was created.",
          "headers": {
            "Location": {
              "description": "The URL of the newly created variable.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/deployment_variable"
          }
        },
        "404": {
          "description": "The account, repository, environment or variable with the given UUID was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "409": {
          "description": "A variable with the provided key already exists.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}": {
    "delete": {
      "description": "Delete a deployment environment level variable.",
      "operationId": "deleteDeploymentVariable",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The environment.",
          "in": "path",
          "name": "environment_uuid",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the variable to delete.",
          "in": "path",
          "name": "variable_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "The variable was deleted."
        },
        "404": {
          "description": "The account, repository, environment or variable with given UUID was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "put": {
      "description": "Update a deployment environment level variable.",
      "operationId": "updateDeploymentVariable",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The environment.",
          "in": "path",
          "name": "environment_uuid",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the variable to update.",
          "in": "path",
          "name": "variable_uuid",
          "required": true,
          "type": "string"
        },
        {
          "description": "The updated deployment variable.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/deployment_variable"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The deployment variable was updated.",
          "schema": {
            "$ref": "#/definitions/deployment_variable"
          }
        },
        "404": {
          "description": "The account, repository, environment or variable with the given UUID was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/deployments/": {
    "get": {
      "description": "Find deployments",
      "operationId": "getDeploymentsForRepository",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The matching deployments.",
          "schema": {
            "$ref": "#/definitions/paginated_deployments"
          }
        }
      },
      "tags": [
        "deployments"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/deployments/{deployment_uuid}": {
    "get": {
      "description": "Retrieve a deployment",
      "operationId": "getDeploymentForRepository",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The deployment UUID.",
          "in": "path",
          "name": "deployment_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The deployment.",
          "schema": {
            "$ref": "#/definitions/deployment"
          }
        },
        "404": {
          "description": "No account, repository or deployment with the UUID provided exists.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "deployments"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/environments/": {
    "get": {
      "description": "Find environments",
      "operationId": "getEnvironmentsForRepository",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The matching environments.",
          "schema": {
            "$ref": "#/definitions/paginated_environments"
          }
        }
      },
      "tags": [
        "deployments"
      ]
    },
    "post": {
      "description": "Create an environment.",
      "operationId": "createEnvironment",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The environment to create.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/deployment_environment"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The environment was created.",
          "headers": {
            "Location": {
              "description": "The URL of the newly created environment.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/deployment_environment"
          }
        },
        "404": {
          "description": "The account or repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "409": {
          "description": "An environment host with the provided name already exists.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "deployments"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/environments/{environment_uuid}": {
    "delete": {
      "description": "Delete an environment",
      "operationId": "deleteEnvironmentForRepository",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The environment UUID.",
          "in": "path",
          "name": "environment_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "The environment was deleted."
        },
        "404": {
          "description": "No account or repository with the UUID provided exists.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "deployments"
      ]
    },
    "get": {
      "description": "Retrieve an environment",
      "operationId": "getEnvironmentForRepository",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The environment UUID.",
          "in": "path",
          "name": "environment_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The environment.",
          "schema": {
            "$ref": "#/definitions/deployment_environment"
          }
        },
        "404": {
          "description": "No account, repository or environment with the UUID provided exists.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "deployments"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/environments/{environment_uuid}/changes/": {
    "post": {
      "description": "Update an environment",
      "operationId": "updateEnvironmentForRepository",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The environment UUID.",
          "in": "path",
          "name": "environment_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "202": {
          "description": "The environment update request was accepted."
        },
        "404": {
          "description": "No account, repository or environment with the UUID provided exists.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "deployments"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines_config": {
    "get": {
      "description": "Retrieve the repository pipelines configuration.",
      "operationId": "getRepositoryPipelineConfig",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The repository pipelines configuration.",
          "schema": {
            "$ref": "#/definitions/pipelines_config"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "put": {
      "description": "Update the pipelines configuration for a repository.",
      "operationId": "updateRepositoryPipelineConfig",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The updated repository pipelines configuration.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pipelines_config"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The repository pipelines configuration was updated.",
          "schema": {
            "$ref": "#/definitions/pipelines_config"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines_config/build_number": {
    "put": {
      "description": "Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.",
      "operationId": "updateRepositoryBuildNumber",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The build number to update.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pipeline_build_number"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The build number has been configured.",
          "schema": {
            "$ref": "#/definitions/pipeline_build_number"
          }
        },
        "400": {
          "description": "The update failed because the next number was invalid (it should be higher than the current number).",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The account or repository was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/": {
    "get": {
      "description": "Retrieve the configured schedules for the given repository.",
      "operationId": "getRepositoryPipelineSchedules",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The list of schedules.",
          "schema": {
            "$ref": "#/definitions/paginated_pipeline_schedules"
          }
        },
        "404": {
          "description": "The account or repository was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "post": {
      "description": "Create a schedule for the given repository.",
      "operationId": "createRepositoryPipelineSchedule",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The schedule to create.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pipeline_schedule"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The created schedule.",
          "schema": {
            "$ref": "#/definitions/pipeline_schedule"
          }
        },
        "400": {
          "description": "There were errors validating the request.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "401": {
          "description": "The maximum limit of schedules for this repository was reached.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The account or repository was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}": {
    "delete": {
      "description": "Delete a schedule.",
      "operationId": "deleteRepositoryPipelineSchedule",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The uuid of the schedule.",
          "in": "path",
          "name": "schedule_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "The schedule was deleted."
        },
        "404": {
          "description": "The account, repository or schedule was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "get": {
      "description": "Retrieve a schedule by its UUID.",
      "operationId": "getRepositoryPipelineSchedule",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The uuid of the schedule.",
          "in": "path",
          "name": "schedule_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The requested schedule.",
          "schema": {
            "$ref": "#/definitions/pipeline_schedule"
          }
        },
        "404": {
          "description": "The account, repository or schedule was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "put": {
      "description": "Update a schedule.",
      "operationId": "updateRepositoryPipelineSchedule",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The uuid of the schedule.",
          "in": "path",
          "name": "schedule_uuid",
          "required": true,
          "type": "string"
        },
        {
          "description": "The schedule to update.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pipeline_schedule"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The schedule is updated.",
          "schema": {
            "$ref": "#/definitions/pipeline_schedule"
          }
        },
        "404": {
          "description": "The account, repository or schedule was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}/executions/": {
    "get": {
      "description": "Retrieve the executions of a given schedule.",
      "operationId": "getRepositoryPipelineScheduleExecutions",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The list of executions of a schedule.",
          "schema": {
            "$ref": "#/definitions/paginated_pipeline_schedule_executions"
          }
        },
        "404": {
          "description": "The account or repository was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair": {
    "delete": {
      "description": "Delete the repository SSH key pair.",
      "operationId": "deleteRepositoryPipelineKeyPair",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "The SSH key pair was deleted."
        },
        "404": {
          "description": "The account, repository or SSH key pair was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "get": {
      "description": "Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.",
      "operationId": "getRepositoryPipelineSshKeyPair",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The SSH key pair.",
          "schema": {
            "$ref": "#/definitions/pipeline_ssh_key_pair"
          }
        },
        "404": {
          "description": "The account, repository or SSH key pair was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "put": {
      "description": "Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.",
      "operationId": "updateRepositoryPipelineKeyPair",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The created or updated SSH key pair.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pipeline_ssh_key_pair"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The SSH key pair was created or updated.",
          "schema": {
            "$ref": "#/definitions/pipeline_ssh_key_pair"
          }
        },
        "404": {
          "description": "The account, repository or SSH key pair was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/": {
    "get": {
      "description": "Find repository level known hosts.",
      "operationId": "getRepositoryPipelineKnownHosts",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The retrieved known hosts.",
          "schema": {
            "$ref": "#/definitions/paginated_pipeline_known_hosts"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "post": {
      "description": "Create a repository level known host.",
      "operationId": "createRepositoryPipelineKnownHost",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The known host to create.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pipeline_known_host"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The known host was created.",
          "headers": {
            "Location": {
              "description": "The URL of the newly created pipeline known host.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/pipeline_known_host"
          }
        },
        "404": {
          "description": "The account or repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "409": {
          "description": "A known host with the provided hostname already exists.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}": {
    "delete": {
      "description": "Delete a repository level known host.",
      "operationId": "deleteRepositoryPipelineKnownHost",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the known host to delete.",
          "in": "path",
          "name": "known_host_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "The known host was deleted."
        },
        "404": {
          "description": "The account, repository or known host with given UUID was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "get": {
      "description": "Retrieve a repository level known host.",
      "operationId": "getRepositoryPipelineKnownHost",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the known host to retrieve.",
          "in": "path",
          "name": "known_host_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The known host.",
          "schema": {
            "$ref": "#/definitions/pipeline_known_host"
          }
        },
        "404": {
          "description": "The account, repository or known host with the specified UUID was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "put": {
      "description": "Update a repository level known host.",
      "operationId": "updateRepositoryPipelineKnownHost",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the known host to update.",
          "in": "path",
          "name": "known_host_uuid",
          "required": true,
          "type": "string"
        },
        {
          "description": "The updated known host.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pipeline_known_host"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The known host was updated.",
          "schema": {
            "$ref": "#/definitions/pipeline_known_host"
          }
        },
        "404": {
          "description": "The account, repository or known host with the given UUID was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/": {
    "get": {
      "description": "Find repository level variables.",
      "operationId": "getRepositoryPipelineVariables",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The retrieved variables.",
          "schema": {
            "$ref": "#/definitions/paginated_pipeline_variables"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "post": {
      "description": "Create a repository level variable.",
      "operationId": "createRepositoryPipelineVariable",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The variable to create.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The variable was created.",
          "headers": {
            "Location": {
              "description": "The URL of the newly created pipeline variable.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        },
        "404": {
          "description": "The account or repository does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "409": {
          "description": "A variable with the provided key already exists.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}": {
    "delete": {
      "description": "Delete a repository level variable.",
      "operationId": "deleteRepositoryPipelineVariable",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the variable to delete.",
          "in": "path",
          "name": "variable_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "The variable was deleted."
        },
        "404": {
          "description": "The account, repository or variable with given UUID was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "get": {
      "description": "Retrieve a repository level variable.",
      "operationId": "getRepositoryPipelineVariable",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the variable to retrieve.",
          "in": "path",
          "name": "variable_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The variable.",
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        },
        "404": {
          "description": "The account, repository or variable with the specified UUID was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "put": {
      "description": "Update a repository level variable.",
      "operationId": "updateRepositoryPipelineVariable",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the variable to update.",
          "in": "path",
          "name": "variable_uuid",
          "required": true,
          "type": "string"
        },
        {
          "description": "The updated variable",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The variable was updated.",
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        },
        "404": {
          "description": "The account, repository or variable with the given UUID was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines/": {
    "get": {
      "description": "Find pipelines",
      "operationId": "getPipelinesForRepository",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The matching pipelines.",
          "schema": {
            "$ref": "#/definitions/paginated_pipelines"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "post": {
      "description": "Endpoint to create and initiate a pipeline. \nThere are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated.\n# Trigger a Pipeline for a branch\nOne way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline. \nThe specified branch will be used to determine which pipeline definition from the `bitbucket-pipelines.yml` file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.\n\n### Example\n\n```\n$ curl -X POST -is -u username:password \\\n  -H 'Content-Type: application/json' \\\n https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\\n  -d '\n  {\n    \"target\": {\n      \"ref_type\": \"branch\", \n      \"type\": \"pipeline_ref_target\", \n      \"ref_name\": \"master\"\n    }\n  }'\n```\n# Trigger a Pipeline for a commit on a branch or tag\nYou can initiate a pipeline for a specific commit and in the context of a specified reference (e.g. a branch, tag or bookmark).\nThe specified reference will be used to determine which pipeline definition from the bitbucket-pipelines.yml file will be applied to initiate the pipeline. The pipeline will clone the repository and then do a checkout the specified reference. \n\nThe following reference types are supported:\n\n* `branch` \n* `named_branch`\n* `bookmark` \n * `tag`\n\n### Example\n\n```\n$ curl -X POST -is -u username:password \\\n  -H 'Content-Type: application/json' \\\n  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\\n  -d '\n  {\n    \"target\": {\n      \"commit\": {\n        \"type\": \"commit\", \n        \"hash\": \"ce5b7431602f7cbba007062eeb55225c6e18e956\"\n      }, \n      \"ref_type\": \"branch\", \n      \"type\": \"pipeline_ref_target\", \n      \"ref_name\": \"master\"\n    }\n  }'\n```\n# Trigger a specific pipeline definition for a commit\nYou can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit. \nIn addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition. The resulting pipeline will then clone the repository and checkout the specified revision.\n\n### Example\n\n```\n$ curl -X POST -is -u username:password \\\n  -H 'Content-Type: application/json' \\\n https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\\n -d '\n  {\n     \"target\": {\n      \"commit\": {\n         \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",\n         \"type\":\"commit\"\n       },\n        \"selector\": {\n           \"type\":\"custom\",\n              \"pattern\":\"Deploy to production\"\n          },\n        \"type\":\"pipeline_commit_target\"\n   }\n  }'\n```\n# Trigger a specific pipeline definition for a commit on a branch or tag\nYou can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit in the context of a specified reference. \nIn addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition, as well as the reference information. The resulting pipeline will then clone the repository a checkout the specified reference.\n\n### Example\n\n```\n$ curl -X POST -is -u username:password \\\n  -H 'Content-Type: application/json' \\\n https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\\n -d '\n  {\n     \"target\": {\n      \"commit\": {\n         \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",\n         \"type\":\"commit\"\n       },\n       \"selector\": {\n          \"type\": \"custom\",\n          \"pattern\": \"Deploy to production\"\n       },\n       \"type\": \"pipeline_ref_target\",\n       \"ref_name\": \"master\",\n       \"ref_type\": \"branch\"\n     }\n  }'\n```\n\n\n# Trigger a custom pipeline with variables\nIn addition to triggering a custom pipeline that is defined in your `bitbucket-pipelines.yml` file as shown in the examples above, you can specify variables that will be available for your build. In the request, provide a list of variables, specifying the following for each variable: key, value, and whether it should be secured or not (this field is optional and defaults to not secured).\n\n### Example\n\n```\n$ curl -X POST -is -u username:password \\\n  -H 'Content-Type: application/json' \\\n https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \\\n -d '\n  {\n    \"target\": {\n      \"type\": \"pipeline_ref_target\",\n      \"ref_type\": \"branch\",\n      \"ref_name\": \"master\",\n      \"selector\": {\n        \"type\": \"custom\",\n        \"pattern\": \"Deploy to production\"\n      }\n    },\n    \"variables\": [\n      {\n        \"key\": \"var1key\",\n        \"value\": \"var1value\",\n        \"secured\": true\n      },\n      {\n        \"key\": \"var2key\",\n        \"value\": \"var2value\"\n      }\n    ]\n  }'\n```\n",
      "operationId": "createPipelineForRepository",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The pipeline to initiate.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pipeline"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The initiated pipeline.",
          "headers": {
            "Location": {
              "description": "The URL of the newly created pipeline.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/pipeline"
          }
        },
        "400": {
          "description": "The account or repository is not enabled, the yml file does not exist in the repository for the given revision, or the request body contained invalid properties.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "The account or repository was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}": {
    "get": {
      "description": "Retrieve a specified pipeline",
      "operationId": "getPipelineForRepository",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The pipeline UUID.",
          "in": "path",
          "name": "pipeline_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The pipeline.",
          "schema": {
            "$ref": "#/definitions/pipeline"
          }
        },
        "404": {
          "description": "No account, repository or pipeline with the UUID provided exists.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/": {
    "get": {
      "description": "Find steps for the given pipeline.",
      "operationId": "getPipelineStepsForRepository",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the pipeline.",
          "in": "path",
          "name": "pipeline_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The steps.",
          "schema": {
            "$ref": "#/definitions/paginated_pipeline_steps"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}": {
    "get": {
      "description": "Retrieve a given step of a pipeline.",
      "operationId": "getPipelineStepForRepository",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the pipeline.",
          "in": "path",
          "name": "pipeline_uuid",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the step.",
          "in": "path",
          "name": "step_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The step.",
          "schema": {
            "$ref": "#/definitions/pipeline_step"
          }
        },
        "404": {
          "description": "No account, repository, pipeline or step with the UUID provided exists for the pipeline with the UUID provided.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/log": {
    "get": {
      "description": "Retrieve the log file for a given step of a pipeline.\n\nThis endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.",
      "operationId": "getPipelineStepLogForRepository",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the pipeline.",
          "in": "path",
          "name": "pipeline_uuid",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the step.",
          "in": "path",
          "name": "step_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "produces": [
        "application/octet-stream"
      ],
      "responses": {
        "200": {
          "description": "The raw log file for this pipeline step."
        },
        "304": {
          "description": "The log has the same etag as the provided If-None-Match header.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "A pipeline with the given UUID does not exist, a step with the given UUID does not exist in the pipeline or a log file does not exist for the given step.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "416": {
          "description": "The requested range does not exist for requests that specified the [HTTP Range header](https://tools.ietf.org/html/rfc7233#section-3.1).",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/logs/{log_uuid}": {
    "get": {}
  },
  "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports": {
    "get": {}
  },
  "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases": {
    "get": {}
  },
  "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases/{test_case_uuid}/test_case_reasons": {
    "get": {}
  },
  "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/stopPipeline": {
    "post": {
      "description": "Signal the stop of a pipeline and all of its steps that not have completed yet.",
      "operationId": "stopPipeline",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the pipeline.",
          "in": "path",
          "name": "pipeline_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "The pipeline has been signaled to stop."
        },
        "400": {
          "description": "The specified pipeline has already completed.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "Either the account, repository or pipeline with the given UUID does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/properties/{app_key}/{property_name}": {
    "delete": {
      "description": "Delete an application property value stored against a repository.",
      "operationId": "deleteRepositoryHostedPropertyValue",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The key of the Connect app.",
          "in": "path",
          "name": "app_key",
          "required": true,
          "type": "string"
        },
        {
          "description": "The name of the property.",
          "in": "path",
          "name": "property_name",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "An empty response."
        }
      },
      "tags": [
        "properties"
      ]
    },
    "get": {
      "description": "Retrieve an application property value stored against a repository.",
      "operationId": "getRepositoryHostedPropertyValue",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The key of the Connect app.",
          "in": "path",
          "name": "app_key",
          "required": true,
          "type": "string"
        },
        {
          "description": "The name of the property.",
          "in": "path",
          "name": "property_name",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The value of the property."
        }
      },
      "tags": [
        "properties"
      ]
    },
    "put": {
      "description": "Update an application property value stored against a repository.",
      "operationId": "updateRepositoryHostedPropertyValue",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The key of the Connect app.",
          "in": "path",
          "name": "app_key",
          "required": true,
          "type": "string"
        },
        {
          "description": "The name of the property.",
          "in": "path",
          "name": "property_name",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "An empty response."
        }
      },
      "tags": [
        "properties"
      ]
    }
  },
  "/repositories/{workspace}/{repo_slug}/pullrequests/{pullrequest_id}/properties/{app_key}/{property_name}": {
    "delete": {
      "description": "Delete an application property value stored against a pull request.",
      "operationId": "deletePullRequestHostedPropertyValue",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The pull request ID.",
          "in": "path",
          "name": "pullrequest_id",
          "required": true,
          "type": "string"
        },
        {
          "description": "The key of the Connect app.",
          "in": "path",
          "name": "app_key",
          "required": true,
          "type": "string"
        },
        {
          "description": "The name of the property.",
          "in": "path",
          "name": "property_name",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "An empty response."
        }
      },
      "tags": [
        "properties"
      ]
    },
    "get": {
      "description": "Retrieve an application property value stored against a pull request.",
      "operationId": "getPullRequestHostedPropertyValue",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The pull request ID.",
          "in": "path",
          "name": "pullrequest_id",
          "required": true,
          "type": "string"
        },
        {
          "description": "The key of the Connect app.",
          "in": "path",
          "name": "app_key",
          "required": true,
          "type": "string"
        },
        {
          "description": "The name of the property.",
          "in": "path",
          "name": "property_name",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The value of the property."
        }
      },
      "tags": [
        "properties"
      ]
    },
    "put": {
      "description": "Update an application property value stored against a pull request.",
      "operationId": "updatePullRequestHostedPropertyValue",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The repository.",
          "in": "path",
          "name": "repo_slug",
          "required": true,
          "type": "string"
        },
        {
          "description": "The pull request ID.",
          "in": "path",
          "name": "pullrequest_id",
          "required": true,
          "type": "string"
        },
        {
          "description": "The key of the Connect app.",
          "in": "path",
          "name": "app_key",
          "required": true,
          "type": "string"
        },
        {
          "description": "The name of the property.",
          "in": "path",
          "name": "property_name",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "An empty response."
        }
      },
      "tags": [
        "properties"
      ]
    }
  },
  "/snippets": {
    "get": {
      "description": "Returns all snippets. Like pull requests, repositories and teams, the\nfull set of snippets is defined by what the current user has access to.\n\nThis includes all snippets owned by the current user, but also all snippets\nowned by any of the teams the user is a member of, or snippets by other\nusers that the current user is either watching or has collaborated on (for\ninstance by commenting on it).\n\nTo limit the set of returned snippets, apply the\n`?role=[owner|contributor|member]` query parameter where the roles are\ndefined as follows:\n\n* `owner`: all snippets owned by the current user\n* `contributor`: all snippets owned by, or watched by the current user\n* `member`: owned by the user, their teams, or watched by the current user\n\nWhen no role is specified, all public snippets are returned, as well as all\nprivately owned snippets watched or commented on.\n\nThe returned response is a normal paginated JSON list. This endpoint\nonly supports `application/json` responses and no\n`multipart/form-data` or `multipart/related`. As a result, it is not\npossible to include the file contents.",
      "parameters": [
        {
          "description": "Filter down the result based on the authenticated user's role (`owner`, `contributor`, or `member`).",
          "enum": [
            "owner",
            "contributor",
            "member"
          ],
          "in": "query",
          "name": "role",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of snippets.",
          "schema": {
            "$ref": "#/definitions/paginated_snippets"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "parameters": [],
    "post": {
      "description": "Creates a new snippet under the authenticated user's account.\n\nSnippets can contain multiple files. Both text and binary files are\nsupported.\n\nThe simplest way to create a new snippet from a local file:\n\n    $ curl -u username:password -X POST https://api.bitbucket.org/2.0/snippets               -F file=@image.png\n\nCreating snippets through curl has a few limitations and so let's look\nat a more complicated scenario.\n\nSnippets are created with a multipart POST. Both `multipart/form-data`\nand `multipart/related` are supported. Both allow the creation of\nsnippets with both meta data (title, etc), as well as multiple text\nand binary files.\n\nThe main difference is that `multipart/related` can use rich encoding\nfor the meta data (currently JSON).\n\n\nmultipart/related (RFC-2387)\n----------------------------\n\nThis is the most advanced and efficient way to create a paste.\n\n    POST /2.0/snippets/evzijst HTTP/1.1\n    Content-Length: 1188\n    Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"\n    MIME-Version: 1.0\n\n    --===============1438169132528273974==\n    Content-Type: application/json; charset=\"utf-8\"\n    MIME-Version: 1.0\n    Content-ID: snippet\n\n    {\n      \"title\": \"My snippet\",\n      \"is_private\": true,\n      \"scm\": \"hg\",\n      \"files\": {\n          \"foo.txt\": {},\n          \"image.png\": {}\n        }\n    }\n\n    --===============1438169132528273974==\n    Content-Type: text/plain; charset=\"us-ascii\"\n    MIME-Version: 1.0\n    Content-Transfer-Encoding: 7bit\n    Content-ID: \"foo.txt\"\n    Content-Disposition: attachment; filename=\"foo.txt\"\n\n    foo\n\n    --===============1438169132528273974==\n    Content-Type: image/png\n    MIME-Version: 1.0\n    Content-Transfer-Encoding: base64\n    Content-ID: \"image.png\"\n    Content-Disposition: attachment; filename=\"image.png\"\n\n    iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m\n    TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB\n    cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5\n    EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ\n    73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN\n    AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==\n    --===============1438169132528273974==--\n\nThe request contains multiple parts and is structured as follows.\n\nThe first part is the JSON document that describes the snippet's\nproperties or meta data. It either has to be the first part, or the\nrequest's `Content-Type` header must contain the `start` parameter to\npoint to it.\n\nThe remaining parts are the files of which there can be zero or more.\nEach file part should contain the `Content-ID` MIME header through\nwhich the JSON meta data's `files` element addresses it. The value\nshould be the name of the file.\n\n`Content-Disposition` is an optional MIME header. The header's\noptional `filename` parameter can be used to specify the file name\nthat Bitbucket should use when writing the file to disk. When present,\n`filename` takes precedence over the value of `Content-ID`.\n\nWhen the JSON body omits the `files` element, the remaining parts are\nnot ignored. Instead, each file is added to the new snippet as if its\nname was explicitly linked (the use of the `files` elements is\nmandatory for some operations like deleting or renaming files).\n\n\nmultipart/form-data\n-------------------\n\nThe use of JSON for the snippet's meta data is optional. Meta data can\nalso be supplied as regular form fields in a more conventional\n`multipart/form-data` request:\n\n    $ curl -X POST -u credentials https://api.bitbucket.org/2.0/snippets               -F title=\"My snippet\"               -F file=@foo.txt -F file=@image.png\n\n    POST /2.0/snippets HTTP/1.1\n    Content-Length: 951\n    Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f\n\n    ------------------------------63a4b224c59f\n    Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"\n    Content-Type: text/plain\n\n    foo\n\n    ------------------------------63a4b224c59f\n    Content-Disposition: form-data; name=\"file\"; filename=\"image.png\"\n    Content-Type: application/octet-stream\n\n    ?PNG\n\n    IHDR?1??I.....\n    ------------------------------63a4b224c59f\n    Content-Disposition: form-data; name=\"title\"\n\n    My snippet\n    ------------------------------63a4b224c59f--\n\nHere the meta data properties are included as flat, top-level form\nfields. The file attachments use the `file` field name. To attach\nmultiple files, simply repeat the field.\n\nThe advantage of `multipart/form-data` over `multipart/related` is\nthat it can be easier to build clients.\n\nEssentially all properties are optional, `title` and `files` included.\n\n\nSharing and Visibility\n----------------------\n\nSnippets can be either public (visible to anyone on Bitbucket, as well\nas anonymous users), or private (visible only to the owner, creator\nand members of the team in case the snippet is owned by a team). This\nis controlled through the snippet's `is_private` element:\n\n* **is_private=false** -- everyone, including anonymous users can view\n  the snippet\n* **is_private=true** -- only the owner and team members (for team\n  snippets) can view it\n\nTo create the snippet under a team account, just append the team name\nto the URL (see `/2.0/snippets/{username}`).",
      "parameters": [
        {
          "description": "The new snippet object.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/snippet"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The newly created snippet object.",
          "headers": {
            "Location": {
              "description": "The URL of the newly created snippet.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/snippet"
          }
        },
        "401": {
          "description": "If the request was not authenticated",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    }
  },
  "/snippets/{username}": {
    "get": {
      "description": "Identical to `/snippets`, except that the result is further filtered\nby the snippet owner and only those that are owned by `{username}` are\nreturned.",
      "parameters": [
        {
          "description": "Filter down the result based on the authenticated user's role (`owner`, `contributor`, or `member`).",
          "enum": [
            "owner",
            "contributor",
            "member"
          ],
          "in": "query",
          "name": "role",
          "required": false,
          "type": "string"
        },
        {
          "description": "Limits the result to snippets owned by this user.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of snippets.",
          "schema": {
            "$ref": "#/definitions/paginated_snippets"
          }
        },
        "404": {
          "description": "If the user does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Identical to `/snippets`, except that the new snippet will be\ncreated under the account specified in the path parameter `{username}`.",
      "parameters": [
        {
          "description": "The new snippet object.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/snippet"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The newly created snippet object.",
          "headers": {
            "Location": {
              "description": "The URL of the newly created snippet.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/snippet"
          }
        },
        "401": {
          "description": "If the request was not authenticated",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If the authenticated user does not have permission to create snippets under the specified account.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    }
  },
  "/snippets/{username}/{encoded_id}": {
    "delete": {
      "description": "Deletes a snippet and returns an empty response.",
      "parameters": [
        {
          "description": "The snippet's id.",
          "in": "path",
          "name": "encoded_id",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "If the snippet was deleted successfully."
        },
        "401": {
          "description": "If the snippet is private and the request was not authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If authenticated user does not have permission to delete the private snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "get": {
      "description": "Retrieves a single snippet.\n\nSnippets support multiple content types:\n\n* application/json\n* multipart/related\n* multipart/form-data\n\n\napplication/json\n----------------\n\nThe default content type of the response is `application/json`.\nSince JSON is always `utf-8`, it cannot reliably contain file contents\nfor files that are not text. Therefore, JSON snippet documents only\ncontain the filename and links to the file contents.\n\nThis means that in order to retrieve all parts of a snippet, N+1\nrequests need to be made (where N is the number of files in the\nsnippet).\n\n\nmultipart/related\n-----------------\n\nTo retrieve an entire snippet in a single response, use the\n`Accept: multipart/related` HTTP request header.\n\n    $ curl -H \"Accept: multipart/related\" https://api.bitbucket.org/2.0/snippets/evzijst/1\n\nResponse:\n\n    HTTP/1.1 200 OK\n    Content-Length: 2214\n    Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"\n    MIME-Version: 1.0\n\n    --===============1438169132528273974==\n    Content-Type: application/json; charset=\"utf-8\"\n    MIME-Version: 1.0\n    Content-ID: snippet\n\n    {\n      \"links\": {\n        \"self\": {\n          \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj\"\n        },\n        \"html\": {\n          \"href\": \"https://bitbucket.org/snippets/evzijst/kypj\"\n        },\n        \"comments\": {\n          \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/comments\"\n        },\n        \"watchers\": {\n          \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/watchers\"\n        },\n        \"commits\": {\n          \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/commits\"\n        }\n      },\n      \"id\": kypj,\n      \"title\": \"My snippet\",\n      \"created_on\": \"2014-12-29T22:22:04.790331+00:00\",\n      \"updated_on\": \"2014-12-29T22:22:04.790331+00:00\",\n      \"is_private\": false,\n      \"files\": {\n        \"foo.txt\": {\n          \"links\": {\n            \"self\": {\n              \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/foo.txt\"\n            },\n            \"html\": {\n              \"href\": \"https://bitbucket.org/snippets/evzijst/kypj#file-foo.txt\"\n            }\n          }\n        },\n        \"image.png\": {\n          \"links\": {\n            \"self\": {\n              \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/image.png\"\n            },\n            \"html\": {\n              \"href\": \"https://bitbucket.org/snippets/evzijst/kypj#file-image.png\"\n            }\n          }\n        }\n      ],\n      \"owner\": {\n        \"username\": \"evzijst\",\n        \"nickname\": \"evzijst\",\n        \"display_name\": \"Erik van Zijst\",\n        \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",\n        \"links\": {\n          \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"\n          },\n          \"html\": {\n            \"href\": \"https://bitbucket.org/evzijst\"\n          },\n          \"avatar\": {\n            \"href\": \"https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\"\n          }\n        }\n      },\n      \"creator\": {\n        \"username\": \"evzijst\",\n        \"nickname\": \"evzijst\",\n        \"display_name\": \"Erik van Zijst\",\n        \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",\n        \"links\": {\n          \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"\n          },\n          \"html\": {\n            \"href\": \"https://bitbucket.org/evzijst\"\n          },\n          \"avatar\": {\n            \"href\": \"https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\"\n          }\n        }\n      }\n    }\n\n    --===============1438169132528273974==\n    Content-Type: text/plain; charset=\"us-ascii\"\n    MIME-Version: 1.0\n    Content-Transfer-Encoding: 7bit\n    Content-ID: \"foo.txt\"\n    Content-Disposition: attachment; filename=\"foo.txt\"\n\n    foo\n\n    --===============1438169132528273974==\n    Content-Type: image/png\n    MIME-Version: 1.0\n    Content-Transfer-Encoding: base64\n    Content-ID: \"image.png\"\n    Content-Disposition: attachment; filename=\"image.png\"\n\n    iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m\n    TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB\n    cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5\n    EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ\n    73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN\n    AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==\n    --===============1438169132528273974==--\n\nmultipart/form-data\n-------------------\n\nAs with creating new snippets, `multipart/form-data` can be used as an\nalternative to `multipart/related`. However, the inherently flat\nstructure of form-data means that only basic, root-level properties\ncan be returned, while nested elements like `links` are omitted:\n\n    $ curl -H \"Accept: multipart/form-data\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj\n\nResponse:\n\n    HTTP/1.1 200 OK\n    Content-Length: 951\n    Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f\n\n    ------------------------------63a4b224c59f\n    Content-Disposition: form-data; name=\"title\"\n    Content-Type: text/plain; charset=\"utf-8\"\n\n    My snippet\n    ------------------------------63a4b224c59f--\n    Content-Disposition: attachment; name=\"file\"; filename=\"foo.txt\"\n    Content-Type: text/plain\n\n    foo\n\n    ------------------------------63a4b224c59f\n    Content-Disposition: attachment; name=\"file\"; filename=\"image.png\"\n    Content-Transfer-Encoding: base64\n    Content-Type: application/octet-stream\n\n    iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m\n    TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB\n    cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5\n    EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ\n    73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN\n    AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==\n    ------------------------------5957323a6b76--",
      "parameters": [
        {
          "description": "The snippet's id.",
          "in": "path",
          "name": "encoded_id",
          "required": true,
          "type": "string"
        }
      ],
      "produces": [
        "application/json",
        "multipart/related",
        "multipart/form-data"
      ],
      "responses": {
        "200": {
          "description": "The snippet object.",
          "schema": {
            "$ref": "#/definitions/snippet"
          }
        },
        "401": {
          "description": "If the snippet is private and the request was not authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If authenticated user does not have access to the private snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "410": {
          "description": "If the snippet marked as spam.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "encoded_id",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "consumes": [
        "application/json",
        "multipart/related",
        "multipart/form-data"
      ],
      "description": "Used to update a snippet. Use this to add and delete files and to\nchange a snippet's title.\n\nTo update a snippet, one can either PUT a full snapshot, or only the\nparts that need to be changed.\n\nThe contract for PUT on this API is that properties missing from the\nrequest remain untouched so that snippets can be efficiently\nmanipulated with differential payloads.\n\nTo delete a property (e.g. the title, or a file), include its name in\nthe request, but omit its value (use `null`).\n\nAs in Git, explicit renaming of files is not supported. Instead, to\nrename a file, delete it and add it again under another name. This can\nbe done atomically in a single request. Rename detection is left to\nthe SCM.\n\nPUT supports three different content types for both request and\nresponse bodies:\n\n* `application/json`\n* `multipart/related`\n* `multipart/form-data`\n\nThe content type used for the request body can be different than that\nused for the response. Content types are specified using standard HTTP\nheaders.\n\nUse the `Content-Type` and `Accept` headers to select the desired\nrequest and response format.\n\n\napplication/json\n----------------\n\nAs with creation and retrieval, the content type determines what\nproperties can be manipulated. `application/json` does not support\nfile contents and is therefore limited to a snippet's meta data.\n\nTo update the title, without changing any of its files:\n\n    $ curl -X POST -H \"Content-Type: application/json\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d '{\"title\": \"Updated title\"}'\n\n\nTo delete the title:\n\n    $ curl -X POST -H \"Content-Type: application/json\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d '{\"title\": null}'\n\nNot all parts of a snippet can be manipulated. The owner and creator\nfor instance are immutable.\n\n\nmultipart/related\n-----------------\n\n`multipart/related` can be used to manipulate all of a snippet's\nproperties. The body is identical to a POST. properties omitted from\nthe request are left unchanged. Since the `start` part contains JSON,\nthe mechanism for manipulating the snippet's meta data is identical\nto `application/json` requests.\n\nTo update one of a snippet's file contents, while also changing its\ntitle:\n\n    PUT /2.0/snippets/evzijst/kypj HTTP/1.1\n    Content-Length: 288\n    Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"\n    MIME-Version: 1.0\n\n    --===============1438169132528273974==\n    Content-Type: application/json; charset=\"utf-8\"\n    MIME-Version: 1.0\n    Content-ID: snippet\n\n    {\n      \"title\": \"My updated snippet\",\n      \"files\": {\n          \"foo.txt\": {}\n        }\n    }\n\n    --===============1438169132528273974==\n    Content-Type: text/plain; charset=\"us-ascii\"\n    MIME-Version: 1.0\n    Content-Transfer-Encoding: 7bit\n    Content-ID: \"foo.txt\"\n    Content-Disposition: attachment; filename=\"foo.txt\"\n\n    Updated file contents.\n\n    --===============1438169132528273974==--\n\nHere only the parts that are changed are included in the body. The\nother files remain untouched.\n\nNote the use of the `files` list in the JSON part. This list contains\nthe files that are being manipulated. This list should have\ncorresponding multiparts in the request that contain the new contents\nof these files.\n\nIf a filename in the `files` list does not have a corresponding part,\nit will be deleted from the snippet, as shown below:\n\n    PUT /2.0/snippets/evzijst/kypj HTTP/1.1\n    Content-Length: 188\n    Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"\n    MIME-Version: 1.0\n\n    --===============1438169132528273974==\n    Content-Type: application/json; charset=\"utf-8\"\n    MIME-Version: 1.0\n    Content-ID: snippet\n\n    {\n      \"files\": {\n        \"image.png\": {}\n      }\n    }\n\n    --===============1438169132528273974==--\n\nTo simulate a rename, delete a file and add the same file under\nanother name:\n\n    PUT /2.0/snippets/evzijst/kypj HTTP/1.1\n    Content-Length: 212\n    Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"\n    MIME-Version: 1.0\n\n    --===============1438169132528273974==\n    Content-Type: application/json; charset=\"utf-8\"\n    MIME-Version: 1.0\n    Content-ID: snippet\n\n    {\n        \"files\": {\n          \"foo.txt\": {},\n          \"bar.txt\": {}\n        }\n    }\n\n    --===============1438169132528273974==\n    Content-Type: text/plain; charset=\"us-ascii\"\n    MIME-Version: 1.0\n    Content-Transfer-Encoding: 7bit\n    Content-ID: \"bar.txt\"\n    Content-Disposition: attachment; filename=\"bar.txt\"\n\n    foo\n\n    --===============1438169132528273974==--\n\n\nmultipart/form-data\n-----------------\n\nAgain, one can also use `multipart/form-data` to manipulate file\ncontents and meta data atomically.\n\n    $ curl -X PUT http://localhost:12345/2.0/snippets/evzijst/kypj             -F title=\"My updated snippet\" -F file=@foo.txt\n\n    PUT /2.0/snippets/evzijst/kypj HTTP/1.1\n    Content-Length: 351\n    Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f\n\n    ------------------------------63a4b224c59f\n    Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"\n    Content-Type: text/plain\n\n    foo\n\n    ------------------------------63a4b224c59f\n    Content-Disposition: form-data; name=\"title\"\n\n    My updated snippet\n    ------------------------------63a4b224c59f\n\nTo delete a file, omit its contents while including its name in the\n`files` field:\n\n    $ curl -X PUT https://api.bitbucket.org/2.0/snippets/evzijst/kypj -F files=image.png\n\n    PUT /2.0/snippets/evzijst/kypj HTTP/1.1\n    Content-Length: 149\n    Content-Type: multipart/form-data; boundary=----------------------------ef8871065a86\n\n    ------------------------------ef8871065a86\n    Content-Disposition: form-data; name=\"files\"\n\n    image.png\n    ------------------------------ef8871065a86--\n\nThe explicit use of the `files` element in `multipart/related` and\n`multipart/form-data` is only required when deleting files.\nThe default mode of operation is for file parts to be processed,\nregardless of whether or not they are listed in `files`, as a\nconvenience to the client.",
      "parameters": [
        {
          "description": "The snippet's id.",
          "in": "path",
          "name": "encoded_id",
          "required": true,
          "type": "string"
        }
      ],
      "produces": [
        "application/json",
        "multipart/related",
        "multipart/form-data"
      ],
      "responses": {
        "200": {
          "description": "The updated snippet object.",
          "schema": {
            "$ref": "#/definitions/snippet"
          }
        },
        "401": {
          "description": "If the snippet is private and the request was not authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If authenticated user does not have permission to update the private snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    }
  },
  "/snippets/{username}/{encoded_id}/{node_id}": {
    "delete": {
      "description": "Deletes the snippet.\n\nNote that this only works for versioned URLs that point to the latest\ncommit of the snippet. Pointing to an older commit results in a 405\nstatus code.\n\nTo delete a snippet, regardless of whether or not concurrent changes\nare being made to it, use `DELETE /snippets/{encoded_id}` instead.",
      "parameters": [
        {
          "description": "The snippet's id.",
          "in": "path",
          "name": "encoded_id",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "If the snippet was deleted successfully."
        },
        "401": {
          "description": "If the snippet is private and the request was not authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If authenticated user does not have permission to delete the private snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "405": {
          "description": "If `{node_id}` is not the latest revision.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "get": {
      "description": "Identical to `GET /snippets/encoded_id`, except that this endpoint\ncan be used to retrieve the contents of the snippet as it was at an\nolder revision, while `/snippets/encoded_id` always returns the\nsnippet's current revision.\n\nNote that only the snippet's file contents are versioned, not its\nmeta data properties like the title.\n\nOther than that, the two endpoints are identical in behavior.",
      "parameters": [
        {
          "description": "The snippet's id.",
          "in": "path",
          "name": "encoded_id",
          "required": true,
          "type": "string"
        },
        {
          "description": "A commit revision (SHA1).",
          "in": "path",
          "name": "node_id",
          "required": true,
          "type": "string"
        }
      ],
      "produces": [
        "application/json",
        "multipart/related",
        "multipart/form-data"
      ],
      "responses": {
        "200": {
          "description": "The snippet object.",
          "schema": {
            "$ref": "#/definitions/snippet"
          }
        },
        "401": {
          "description": "If the snippet is private and the request was not authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If authenticated user does not have access to the private snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet, or the revision does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "node_id",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "encoded_id",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "consumes": [
        "application/json",
        "multipart/related",
        "multipart/form-data"
      ],
      "description": "Identical to `UPDATE /snippets/encoded_id`, except that this endpoint\ntakes an explicit commit revision. Only the snippet's \"HEAD\"/\"tip\"\n(most recent) version can be updated and requests on all other,\nolder revisions fail by returning a 405 status.\n\nUsage of this endpoint over the unrestricted `/snippets/encoded_id`\ncould be desired if the caller wants to be sure no concurrent\nmodifications have taken place between the moment of the UPDATE\nrequest and the original GET.\n\nThis can be considered a so-called \"Compare And Swap\", or CAS\noperation.\n\nOther than that, the two endpoints are identical in behavior.",
      "parameters": [
        {
          "description": "The snippet's id.",
          "in": "path",
          "name": "encoded_id",
          "required": true,
          "type": "string"
        },
        {
          "description": "A commit revision (SHA1).",
          "in": "path",
          "name": "node_id",
          "required": true,
          "type": "string"
        }
      ],
      "produces": [
        "application/json",
        "multipart/related",
        "multipart/form-data"
      ],
      "responses": {
        "200": {
          "description": "The updated snippet object.",
          "schema": {
            "$ref": "#/definitions/snippet"
          }
        },
        "401": {
          "description": "If the snippet is private and the request was not authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If authenticated user does not have permission to update the private snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet or the revision does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "405": {
          "description": "If `{node_id}` is not the latest revision.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    }
  },
  "/snippets/{username}/{encoded_id}/{node_id}/files/{path}": {
    "get": {
      "description": "Retrieves the raw contents of a specific file in the snippet. The\n`Content-Disposition` header will be \"attachment\" to avoid issues with\nmalevolent executable files.\n\nThe file's mime type is derived from its filename and returned in the\n`Content-Type` header.\n\nNote that for text files, no character encoding is included as part of\nthe content type.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "Returns the contents of the specified file.",
          "headers": {
            "Content-Disposition": {
              "description": "attachment",
              "type": "string"
            },
            "Content-Type": {
              "description": "The mime type as derived from the filename",
              "type": "string"
            }
          }
        },
        "403": {
          "description": "If the authenticated user does not have access to the snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the file or snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "path",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "node_id",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "encoded_id",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/snippets/{username}/{encoded_id}/{revision}/diff": {
    "get": {
      "description": "Returns the diff of the specified commit against its first parent.\n\nNote that this resource is different in functionality from the `patch`\nresource.\n\nThe differences between a diff and a patch are:\n\n* patches have a commit header with the username, message, etc\n* diffs support the optional `path=foo/bar.py` query param to filter the\n  diff to just that one file diff (not supported for patches)\n* for a merge, the diff will show the diff between the merge commit and\n  its first parent (identical to how PRs work), while patch returns a\n  response containing separate patches for each commit on the second\n  parent's ancestry, up to the oldest common ancestor (identical to\n  its reachability).\n\nNote that the character encoding of the contents of the diff is\nunspecified as Git and Mercurial do not track this, making it hard for\nBitbucket to reliably determine this.",
      "parameters": [
        {
          "description": "When used, only one the diff of the specified file will be returned.",
          "in": "query",
          "name": "path",
          "type": "string"
        },
        {
          "description": "The snippet id.",
          "in": "path",
          "name": "encoded_id",
          "required": true,
          "type": "string"
        },
        {
          "description": "A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like `staging..production`.",
          "in": "path",
          "name": "revision",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The raw diff contents."
        },
        "403": {
          "description": "If the authenticated user does not have access to the snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "encoded_id",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "revision",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/snippets/{username}/{encoded_id}/{revision}/patch": {
    "get": {
      "description": "Returns the patch of the specified commit against its first\nparent.\n\nNote that this resource is different in functionality from the `diff`\nresource.\n\nThe differences between a diff and a patch are:\n\n* patches have a commit header with the username, message, etc\n* diffs support the optional `path=foo/bar.py` query param to filter the\n  diff to just that one file diff (not supported for patches)\n* for a merge, the diff will show the diff between the merge commit and\n  its first parent (identical to how PRs work), while patch returns a\n  response containing separate patches for each commit on the second\n  parent's ancestry, up to the oldest common ancestor (identical to\n  its reachability).\n\nNote that the character encoding of the contents of the patch is\nunspecified as Git and Mercurial do not track this, making it hard for\nBitbucket to reliably determine this.",
      "parameters": [
        {
          "description": "The snippet id.",
          "in": "path",
          "name": "encoded_id",
          "required": true,
          "type": "string"
        },
        {
          "description": "A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like `staging..production`.",
          "in": "path",
          "name": "revision",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The raw patch contents."
        },
        "403": {
          "description": "If the authenticated user does not have access to the snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "encoded_id",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "revision",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/snippets/{username}/{encoded_id}/comments": {
    "get": {
      "description": "Used to retrieve a paginated list of all comments for a specific\nsnippet.\n\nThis resource works identical to commit and pull request comments.\n\nThe default sorting is oldest to newest and can be overridden with\nthe `sort` query parameter.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "A paginated list of snippet comments, ordered by creation date.",
          "schema": {
            "$ref": "#/definitions/paginated_snippet_comments"
          }
        },
        "403": {
          "description": "If the authenticated user does not have access to the snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "encoded_id",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new comment.\n\nThe only required field in the body is `content.raw`.\n\nTo create a threaded reply to an existing comment, include `parent.id`.",
      "parameters": [
        {
          "description": "The contents of the new comment.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/snippet"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The newly created comment.",
          "headers": {
            "Location": {
              "description": "The URL of the new comment",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/snippet"
          }
        },
        "403": {
          "description": "If the authenticated user does not have access to the snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    }
  },
  "/snippets/{username}/{encoded_id}/comments/{comment_id}": {
    "delete": {
      "description": "Deletes a snippet comment.\n\nComments can only be removed by their author.",
      "parameters": [],
      "responses": {
        "204": {
          "description": "Indicates the comment was deleted successfully."
        },
        "403": {
          "description": "If the authenticated user is not the author of the comment.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the comment or the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "get": {
      "description": "Returns the specific snippet comment.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The specified comment.",
          "schema": {
            "$ref": "#/definitions/snippet_comment"
          }
        },
        "403": {
          "description": "If the authenticated user does not have access to the snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the comment or snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "comment_id",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "encoded_id",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Updates a comment.\n\nComments can only be updated by their author.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The updated comment object."
        },
        "403": {
          "description": "If the authenticated user does not have access to the snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the comment or snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    }
  },
  "/snippets/{username}/{encoded_id}/commits": {
    "get": {
      "description": "Returns the changes (commits) made on this snippet.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The paginated list of snippet commits.",
          "schema": {
            "$ref": "#/definitions/paginated_snippet_commit"
          }
        },
        "403": {
          "description": "If the authenticated user does not have access to the snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "encoded_id",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/snippets/{username}/{encoded_id}/commits/{revision}": {
    "get": {
      "description": "",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The specified snippet commit.",
          "schema": {
            "$ref": "#/definitions/snippet_commit"
          }
        },
        "403": {
          "description": "If the authenticated user does not have access to the snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the commit or the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "encoded_id",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "revision",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/snippets/{username}/{encoded_id}/files/{path}": {
    "get": {
      "description": "Convenience resource for getting to a snippet's raw files without the\nneed for first having to retrieve the snippet itself and having to pull\nout the versioned file links.",
      "parameters": [],
      "responses": {
        "302": {
          "description": "A redirect to the most recent revision of the specified file.",
          "headers": {
            "Location": {
              "description": "The URL of the most recent file revision.",
              "type": "string"
            }
          }
        },
        "403": {
          "description": "If the authenticated user does not have access to the snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippet"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "path",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "encoded_id",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/snippets/{username}/{encoded_id}/watch": {
    "delete": {
      "description": "Used to stop watching a specific snippet. Returns 204 (No Content)\nto indicate success.",
      "parameters": [
        {
          "description": "The snippet id.",
          "in": "path",
          "name": "encoded_id",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "Indicates the user stopped watching the snippet successfully.",
          "schema": {
            "$ref": "#/definitions/paginated_users"
          }
        },
        "401": {
          "description": "If the request was not authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "get": {
      "description": "Used to check if the current user is watching a specific snippet.\n\nReturns 204 (No Content) if the user is watching the snippet and 404 if\nnot.\n\nHitting this endpoint anonymously always returns a 404.",
      "parameters": [
        {
          "description": "The snippet id.",
          "in": "path",
          "name": "encoded_id",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "If the authenticated user is watching the snippet.",
          "schema": {
            "$ref": "#/definitions/paginated_users"
          }
        },
        "404": {
          "description": "If the snippet does not exist, or if the authenticated user is not watching the snippet.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "encoded_id",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Used to start watching a specific snippet. Returns 204 (No Content).",
      "parameters": [
        {
          "description": "The snippet id.",
          "in": "path",
          "name": "encoded_id",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "Indicates the authenticated user is now watching the snippet.",
          "schema": {
            "$ref": "#/definitions/paginated_users"
          }
        },
        "401": {
          "description": "If the request was not authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    }
  },
  "/snippets/{username}/{encoded_id}/watchers": {
    "get": {
      "deprecated": true,
      "description": "Returns a paginated list of all users watching a specific snippet.",
      "parameters": [
        {
          "description": "The snippet id.",
          "in": "path",
          "name": "encoded_id",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The paginated list of users watching this snippet",
          "schema": {
            "$ref": "#/definitions/paginated_users"
          }
        },
        "404": {
          "description": "If the snippet does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "snippet"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "snippets"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "encoded_id",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/teams": {
    "get": {
      "description": "Returns all the teams that the authenticated user is associated\nwith.",
      "parameters": [
        {
          "description": "\nFilters the teams based on the authenticated user's role on each team.\n\n* **member**: returns a list of all the teams which the caller is a member of\n  at least one team group or repository owned by the team\n* **contributor**: returns a list of teams which the caller has write access\n  to at least one repository owned by the team\n* **admin**: returns a list teams which the caller has team administrator access\n",
          "enum": [
            "admin",
            "contributor",
            "member"
          ],
          "in": "query",
          "name": "role",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of teams.",
          "schema": {
            "$ref": "#/definitions/paginated_teams"
          }
        },
        "401": {
          "description": "When the request wasn't authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "team"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "teams"
      ]
    },
    "parameters": []
  },
  "/teams/{username}": {
    "get": {
      "description": "Gets the public information associated with a team.\n\nIf the team's profile is private, `location`, `website` and\n`created_on` elements are omitted.",
      "parameters": [
        {
          "description": "The team's username or UUID.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The team object",
          "schema": {
            "$ref": "#/definitions/team"
          }
        },
        "404": {
          "description": "If no team exists for the specified name or UUID, or if the specified account is a personal account, not a team account.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "teams"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/teams/{username}/followers": {
    "get": {
      "description": "Returns the list of accounts that are following this team.",
      "parameters": [
        {
          "description": "The team's username",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of user objects.",
          "schema": {
            "$ref": "#/definitions/paginated_users"
          }
        },
        "404": {
          "description": "If no team exists for the specified name, or if the specified account is a personal account, not a team account.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "teams"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/teams/{username}/following": {
    "get": {
      "description": "Returns the list of accounts this team is following.",
      "parameters": [
        {
          "description": "The team's username",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of user objects.",
          "schema": {
            "$ref": "#/definitions/paginated_users"
          }
        },
        "404": {
          "description": "If no team exists for the specified name, or if the specified account is a personal account, not a team account.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "account"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "teams"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/teams/{username}/hooks": {
    "get": {
      "description": "Returns a paginated list of webhooks installed on this team.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The paginated list of installed webhooks.",
          "schema": {
            "$ref": "#/definitions/paginated_webhook_subscriptions"
          }
        },
        "403": {
          "description": "If the authenticated user is not an admin on the specified team.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the specified team does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "teams",
        "webhooks"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new webhook on the specified team.\n\nTeam webhooks are fired for events from all repositories belonging to\nthat team account.\n\nNote that only admins can install webhooks on teams.",
      "parameters": [],
      "responses": {
        "201": {
          "description": "The newly installed webhook.",
          "headers": {
            "Location": {
              "description": "The URL of new newly created webhook.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/webhook_subscription"
          }
        },
        "403": {
          "description": "If the authenticated user is not an admin on the specified team.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the specified team does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "teams",
        "webhooks"
      ]
    }
  },
  "/teams/{username}/hooks/{uid}": {
    "delete": {
      "description": "Deletes the specified webhook subscription from the given team\naccount.",
      "parameters": [
        {
          "description": "The installed webhook's id",
          "in": "path",
          "name": "uid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "When the webhook was deleted successfully"
        },
        "403": {
          "description": "If the authenticated user does not have permission to delete the webhook.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the webhook or team does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "teams",
        "webhooks"
      ]
    },
    "get": {
      "description": "Returns the webhook with the specified id installed on the given\nteam account.",
      "parameters": [
        {
          "description": "The installed webhook's id.",
          "in": "path",
          "name": "uid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The webhook subscription object.",
          "schema": {
            "$ref": "#/definitions/webhook_subscription"
          }
        },
        "404": {
          "description": "If the webhook or team does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "teams",
        "webhooks"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "uid",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Updates the specified webhook subscription.\n\nThe following properties can be mutated:\n\n* `description`\n* `url`\n* `active`\n* `events`",
      "parameters": [
        {
          "description": "The installed webhook's id",
          "in": "path",
          "name": "uid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The webhook subscription object.",
          "schema": {
            "$ref": "#/definitions/webhook_subscription"
          }
        },
        "403": {
          "description": "If the authenticated user does not have permission to update the webhook.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the webhook or team does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "teams",
        "webhooks"
      ]
    }
  },
  "/teams/{username}/members": {
    "get": {
      "description": "Returns all members of the specified team. Any member of any of the\nteam's groups is considered a member of the team. This includes users\nin groups that may not actually have access to any of the team's\nrepositories.\n\nThis operation has been deprecated due to privacy changes.\nSee the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/)\nfor details.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "All members",
          "examples": {
            "application/json": {
              "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
              "account_status": "active",
              "display_name": "Example Username",
              "links": {
                "avatar": {
                  "href": "https://bitbucket.org/account/example-username/avatar/"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/users/example-username"
                }
              },
              "nickname": "example-username",
              "type": "user",
              "username": "example-username",
              "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
            }
          },
          "schema": {
            "$ref": "#/definitions/user"
          }
        },
        "404": {
          "description": "When the team does not exist, or multiple teams with the same name exist that differ only in casing and the URL did not match the exact casing of a particular one.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "account"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "teams"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/teams/{username}/permissions": {
    "get": {
      "description": "Returns an object for each team permission a user on the team has.\n\nPermissions returned are effective permissions  if a user is a member of\nmultiple groups with distinct roles, only the highest level is returned.\n\nPermissions can be:\n\n* `admin`\n* `collaborator`\n\nOnly users with admin permission for the team may access this resource.\n\nExample:\n\n```\n$ curl https://api.bitbucket.org/2.0/teams/atlassian_tutorial/permissions\n\n{\n  \"pagelen\": 10,\n  \"values\": [\n    {\n      \"permission\": \"admin\",\n      \"type\": \"team_permission\",\n      \"user\": {\n        \"type\": \"user\",\n        \"nickname\": \"evzijst\",\n        \"display_name\": \"Erik van Zijst\",\n        \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\"\n      },\n      \"team\": {\n        \"display_name\": \"Atlassian Bitbucket\",\n        \"uuid\": \"{4cc6108a-a241-4db0-96a5-64347ac04f87}\"\n      }\n    },\n    {\n      \"permission\": \"collaborator\",\n      \"type\": \"team_permission\",\n      \"user\": {\n        \"type\": \"user\",\n        \"nickname\": \"seanaty\",\n        \"display_name\": \"Sean Conaty\",\n        \"uuid\": \"{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\"\n      },\n      \"team\": {\n        \"display_name\": \"Atlassian Bitbucket\",\n        \"uuid\": \"{4cc6108a-a241-4db0-96a5-64347ac04f87}\"\n      }\n    }\n  ],\n  \"page\": 1,\n  \"size\": 2\n}\n```\n\nResults may be further [filtered or sorted](../../../meta/filtering) by\nteam, user, or permission by adding the following query string\nparameters:\n\n* `q=user.uuid=\"{d301aafa-d676-4ee0-88be-962be7417567}\"` or `q=permission=\"admin\"`\n* `sort=team.display_name`\n\nNote that the query parameter values need to be URL escaped so that `=`\nwould become `%3D`.",
      "parameters": [
        {
          "description": "\nQuery string to narrow down the response as per\n[filtering and sorting](../../../meta/filtering).",
          "in": "query",
          "name": "q",
          "required": false,
          "type": "string"
        },
        {
          "description": "\nName of a response property sort the result by as per\n[filtering and sorting](../../../meta/filtering#query-sort).\n",
          "in": "query",
          "name": "sort",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "Repositories owned by a team.",
          "schema": {
            "$ref": "#/definitions/paginated_team_permissions"
          }
        },
        "403": {
          "description": "The requesting user isn't an admin of the team.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "team"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": []
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/teams/{username}/permissions/repositories": {
    "get": {
      "description": "Returns an object for each repository permission for all of a\nteams repositories.\n\nIf the username URL parameter refers to a user account instead of\na team account, an object containing the repository permissions\nof all the username's repositories will be returned.\n\nPermissions returned are effective permissions  the highest level of\npermission the user has. This does not include public repositories that\nusers are not granted any specific permission in, and does not\ndistinguish between direct and indirect privileges.\n\nOnly users with admin permission for the team may access this resource.\n\nPermissions can be:\n\n* `admin`\n* `write`\n* `read`\n\nExample:\n\n```\n$ curl https://api.bitbucket.org/2.0/teams/atlassian_tutorial/permissions/repositories\n\n{\n  \"pagelen\": 10,\n  \"values\": [\n    {\n      \"type\": \"repository_permission\",\n      \"user\": {\n        \"type\": \"user\",\n        \"display_name\": \"Erik van Zijst\",\n        \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\"\n      },\n      \"repository\": {\n        \"type\": \"repository\",\n        \"name\": \"geordi\",\n        \"full_name\": \"bitbucket/geordi\",\n        \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"\n      },\n      \"permission\": \"admin\"\n    },\n    {\n      \"type\": \"repository_permission\",\n      \"user\": {\n        \"type\": \"user\",\n        \"display_name\": \"Sean Conaty\",\n        \"uuid\": \"{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\"\n      },\n      \"repository\": {\n        \"type\": \"repository\",\n        \"name\": \"geordi\",\n        \"full_name\": \"bitbucket/geordi\",\n        \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"\n      },\n      \"permission\": \"write\"\n    }\n  ],\n  \"page\": 1,\n  \"size\": 2\n}\n```\n\nResults may be further [filtered or sorted](../../../../meta/filtering)\nby repository, user, or permission by adding the following query string\nparameters:\n\n* `q=repository.name=\"geordi\"` or `q=permission>\"read\"`\n* `sort=user.display_name`\n\nNote that the query parameter values need to be URL escaped so that `=`\nwould become `%3D`.",
      "parameters": [
        {
          "description": "\nQuery string to narrow down the response as per\n[filtering and sorting](../../../../meta/filtering).",
          "in": "query",
          "name": "q",
          "required": false,
          "type": "string"
        },
        {
          "description": "\nName of a response property sort the result by as per\n[filtering and sorting](../../../../meta/filtering#query-sort).\n",
          "in": "query",
          "name": "sort",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "List of team's repository permissions.",
          "schema": {
            "$ref": "#/definitions/paginated_repository_permissions"
          }
        },
        "403": {
          "description": "The requesting user isn't an admin of the team.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "team"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": []
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/teams/{username}/permissions/repositories/{repo_slug}": {
    "get": {
      "description": "Returns an object for each repository permission of a given repository.\n\nIf the username URL parameter refers to a user account instead of\na team account, an object containing the repository permissions\nof the username's repository will be returned.\n\nPermissions returned are effective permissions  the highest level of\npermission the user has. This does not include public repositories that\nusers are not granted any specific permission in, and does not\ndistinguish between direct and indirect privileges.\n\nOnly users with admin permission for the repository may access this resource.\n\nPermissions can be:\n\n* `admin`\n* `write`\n* `read`\n\nExample:\n\n```\n$ curl https://api.bitbucket.org/2.0/teams/atlassian_tutorial/permissions/repositories/geordi\n\n{\n  \"pagelen\": 10,\n  \"values\": [\n    {\n      \"type\": \"repository_permission\",\n      \"user\": {\n        \"type\": \"user\",\n        \"display_name\": \"Erik van Zijst\",\n        \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\"\n      },\n      \"repository\": {\n        \"type\": \"repository\",\n        \"name\": \"geordi\",\n        \"full_name\": \"bitbucket/geordi\",\n        \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"\n      },\n      \"permission\": \"admin\"\n    },\n    {\n      \"type\": \"repository_permission\",\n      \"user\": {\n        \"type\": \"user\",\n        \"display_name\": \"Sean Conaty\",\n        \"uuid\": \"{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\"\n      },\n      \"repository\": {\n        \"type\": \"repository\",\n        \"name\": \"geordi\",\n        \"full_name\": \"bitbucket/geordi\",\n        \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"\n      },\n      \"permission\": \"write\"\n    }\n  ],\n  \"page\": 1,\n  \"size\": 2\n}\n```\n\nResults may be further [filtered or sorted](../../../../meta/filtering)\nby user, or permission by adding the following query string parameters:\n\n* `q=permission>\"read\"`\n* `sort=user.display_name`\n\nNote that the query parameter values need to be URL escaped so that `=`\nwould become `%3D`.",
      "parameters": [
        {
          "description": "\nQuery string to narrow down the response as per\n[filtering and sorting](../../../../meta/filtering).",
          "in": "query",
          "name": "q",
          "required": false,
          "type": "string"
        },
        {
          "description": "\nName of a response property sort the result by as per\n[filtering and sorting](../../../../meta/filtering#query-sort).\n",
          "in": "query",
          "name": "sort",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "List of repository's repository permissions.",
          "schema": {
            "$ref": "#/definitions/paginated_repository_permissions"
          }
        },
        "403": {
          "description": "The requesting user isn't an admin of the repository.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": []
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "This can either be the repository slug or the UUID of the repository,\nsurrounded by curly-braces, for example: `{repository UUID}`.\n",
        "in": "path",
        "name": "repo_slug",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/teams/{username}/pipelines_config/variables/": {
    "get": {
      "description": "Find account level variables.",
      "operationId": "getPipelineVariablesForTeam",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The found account level variables.",
          "schema": {
            "$ref": "#/definitions/paginated_pipeline_variables"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "post": {
      "description": "Create an account level variable.",
      "operationId": "createPipelineVariableForTeam",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The variable to create.",
          "in": "body",
          "name": "_body",
          "required": false,
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The created variable.",
          "headers": {
            "Location": {
              "description": "The URL of the newly created pipeline variable.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        },
        "404": {
          "description": "The account does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "409": {
          "description": "A variable with the provided key already exists.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/teams/{username}/pipelines_config/variables/{variable_uuid}": {
    "delete": {
      "description": "Delete a team level variable.",
      "operationId": "deletePipelineVariableForTeam",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the variable to delete.",
          "in": "path",
          "name": "variable_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "The variable was deleted"
        },
        "404": {
          "description": "The account or the variable with the provided UUID does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "get": {
      "description": "Retrieve a team level variable.",
      "operationId": "getPipelineVariableForTeam",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the variable to retrieve.",
          "in": "path",
          "name": "variable_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The variable.",
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        },
        "404": {
          "description": "The account or variable with the given UUID was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "put": {
      "description": "Update a team level variable.",
      "operationId": "updatePipelineVariableForTeam",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the variable.",
          "in": "path",
          "name": "variable_uuid",
          "required": true,
          "type": "string"
        },
        {
          "description": "The updated variable.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The variable was updated.",
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        },
        "404": {
          "description": "The account or the variable was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/teams/{username}/projects/": {
    "get": {
      "description": "",
      "parameters": [],
      "responses": {
        "200": {
          "description": "A paginated list of projects that belong to the specified team.",
          "schema": {
            "$ref": "#/definitions/paginated_projects"
          }
        },
        "403": {
          "description": "The requesting user isn't authorized to read the list of projects for the specified team.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "A team doesn't exist at this location.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "project"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "projects"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new project.\n\nNote that the avatar has to be embedded as either a data-url\nor a URL to an external image as shown in the examples below:\n\n```\n$ body=$(cat << EOF\n{\n    \"name\": \"Mars Project\",\n    \"key\": \"MARS\",\n    \"description\": \"Software for colonizing mars.\",\n    \"links\": {\n        \"avatar\": {\n            \"href\": \"data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/...\"\n        }\n    },\n    \"is_private\": false\n}\nEOF\n)\n$ curl -H \"Content-Type: application/json\" \\\n       -X POST \\\n       -d \"$body\" \\\n       https://api.bitbucket.org/2.0/teams/teams-in-space/projects/ | jq .\n{\n  // Serialized project document\n}\n```\n\nor even:\n\n```\n$ body=$(cat << EOF\n{\n    \"name\": \"Mars Project\",\n    \"key\": \"MARS\",\n    \"description\": \"Software for colonizing mars.\",\n    \"links\": {\n        \"avatar\": {\n            \"href\": \"http://i.imgur.com/72tRx4w.gif\"\n        }\n    },\n    \"is_private\": false\n}\nEOF\n)\n$ curl -H \"Content-Type: application/json\" \\\n       -X POST \\\n       -d \"$body\" \\\n       https://api.bitbucket.org/2.0/teams/teams-in-space/projects/ | jq .\n{\n  // Serialized project document\n}\n```",
      "parameters": [
        {
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/project"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "A new project has been created.",
          "headers": {
            "Location": {
              "description": "The location of the newly created project",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/project"
          }
        },
        "403": {
          "description": "The requesting user isn't authorized to create the project.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "A team doesn't exist at this location.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "project:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "projects"
      ]
    }
  },
  "/teams/{username}/projects/{project_key}": {
    "delete": {
      "description": "",
      "parameters": [],
      "responses": {
        "204": {
          "description": "Successful deletion."
        },
        "403": {
          "description": "The requesting user isn't authorized to delete the project or the project isn't empty.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "A project isn't hosted at this location.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "project:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "projects"
      ]
    },
    "get": {
      "description": "",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The project object.",
          "schema": {
            "$ref": "#/definitions/project"
          }
        },
        "403": {
          "description": "The requesting user isn't authorized to access the project.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "A project isn't hosted at this location.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "project"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "projects"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "description": "The project in question. This can either be the actual `key` assigned\nto the project or the `UUID` (surrounded by curly-braces (`{}`)).\n",
        "in": "path",
        "name": "project_key",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Since this endpoint can be used to both update and to create a\nproject, the request body depends on the intent.\n\n### Creation\n\nSee the POST documentation for the project collection for an\nexample of the request body.\n\nNote: The `key` should not be specified in the body of request\n(since it is already present in the URL). The `name` is required,\neverything else is optional.\n\n### Update\n\nSee the POST documentation for the project collection for an\nexample of the request body.\n\nNote: The key is not required in the body (since it is already in\nthe URL). The key may be specified in the body, if the intent is\nto change the key itself. In such a scenario, the location of the\nproject is changed and is returned in the `Location` header of the\nresponse.",
      "parameters": [
        {
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/project"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The existing project is has been updated.",
          "headers": {
            "Location": {
              "description": "The location of the project. This header is only provided\nwhen the project key is updated.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/project"
          }
        },
        "201": {
          "description": "A new project has been created.",
          "headers": {
            "Location": {
              "description": "The location of the newly created project",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/project"
          }
        },
        "403": {
          "description": "The requesting user isn't authorized to update or create the project.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "A team doesn't exist at the location. Note that the project's absence from this location doesn't raise a 404, since a PUT at a non-existent location can be used to create a new project.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "project:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "projects"
      ]
    }
  },
  "/teams/{username}/repositories": {
    "get": {
      "description": "All repositories owned by a user/team. This includes private\nrepositories, but filtered down to the ones that the calling user has\naccess to.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "users",
        "teams"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/teams/{username}/search/code": {
    "get": {
      "operationId": "searchAccount",
      "parameters": [
        {
          "description": "The account to search in; either the username or the UUID in curly braces",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The search query",
          "in": "query",
          "name": "search_query",
          "required": true,
          "type": "string"
        },
        {
          "default": 1,
          "description": "Which page of the search results to retrieve",
          "format": "int32",
          "in": "query",
          "name": "page",
          "required": false,
          "type": "integer"
        },
        {
          "default": 10,
          "description": "How many search results to retrieve per page",
          "format": "int32",
          "in": "query",
          "name": "pagelen",
          "required": false,
          "type": "integer"
        }
      ],
      "produces": [
        "application/json"
      ],
      "responses": {
        "200": {
          "description": "Successful search",
          "schema": {
            "$ref": "#/definitions/search_result_page"
          }
        },
        "400": {
          "description": "If the search request was invalid due to one of the following reasons:\n* the specified type of target account doesn't match the actual account type;\n* malformed pagination properties;\n* missing or malformed search query, in the latter case an error key will be returned in `error.data.key` property.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "Search is not enabled for the requested team, navigate to [https://bitbucket.org/search](https://bitbucket.org/search) to turn it on",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "429": {
          "description": "Too many requests, try again later",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "summary": "Search for code in the repositories of the specified team",
      "tags": [
        "search"
      ]
    }
  },
  "/user": {
    "get": {
      "description": "Returns the currently logged in user.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The current user.",
          "examples": {
            "application/json": {
              "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
              "account_status": "active",
              "created_on": "2018-06-20T23:17:33.616037+00:00",
              "display_name": "Example Username",
              "is_staff": false,
              "links": {
                "avatar": {
                  "href": "https://bitbucket.org/account/example-username/avatar/"
                },
                "followers": {
                  "href": "https://api.bitbucket.org/2.0/users/example-username/followers"
                },
                "following": {
                  "href": "https://api.bitbucket.org/2.0/users/example-username/following"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/"
                },
                "repositories": {
                  "href": "https://api.bitbucket.org/2.0/repositories/example-username"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/users/example-username"
                },
                "snippets": {
                  "href": "https://api.bitbucket.org/2.0/snippets/example-username"
                }
              },
              "location": null,
              "nickname": "example-username",
              "type": "user",
              "username": "example-username",
              "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}",
              "website": null
            }
          },
          "schema": {
            "$ref": "#/definitions/user"
          }
        },
        "401": {
          "description": "When the request wasn't authenticated.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "account"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "users"
      ]
    },
    "parameters": []
  },
  "/user/emails": {
    "get": {
      "description": "Returns all the authenticated user's email addresses. Both\nconfirmed and unconfirmed.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "email"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "users"
      ]
    },
    "parameters": []
  },
  "/user/emails/{email}": {
    "get": {
      "description": "Returns details about a specific one of the authenticated user's\nemail addresses.\n\nDetails describe whether the address has been confirmed by the user and\nwhether it is the user's primary address or not.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "email"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "users"
      ]
    },
    "parameters": [
      {
        "in": "path",
        "name": "email",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/user/permissions/repositories": {
    "get": {
      "description": "Returns an object for each repository the caller has explicit access\nto and their effective permission  the highest level of permission the\ncaller has. This does not return public repositories that the user was\nnot granted any specific permission in, and does not distinguish between\ndirect and indirect privileges.\n\nPermissions can be:\n\n* `admin`\n* `write`\n* `read`\n\nExample:\n\n```\n$ curl https://api.bitbucket.org/2.0/user/permissions/repositories\n\n{\n  \"pagelen\": 10,\n  \"values\": [\n    {\n      \"type\": \"repository_permission\",\n      \"user\": {\n        \"type\": \"user\",\n        \"nickname\": \"evzijst\",\n        \"display_name\": \"Erik van Zijst\",\n        \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\"\n      },\n      \"repository\": {\n        \"type\": \"repository\",\n        \"name\": \"geordi\",\n        \"full_name\": \"bitbucket/geordi\",\n        \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"\n      },\n      \"permission\": \"admin\"\n    }\n  ],\n  \"page\": 1,\n  \"size\": 1\n}\n```\n\nResults may be further [filtered or sorted](../../../meta/filtering) by\nrepository or permission by adding the following query string\nparameters:\n\n* `q=repository.name=\"geordi\"` or `q=permission>\"read\"`\n* `sort=repository.name`\n\nNote that the query parameter values need to be URL escaped so that `=`\nwould become `%3D`.",
      "parameters": [
        {
          "description": "\nQuery string to narrow down the response as per\n[filtering and sorting](../../../meta/filtering).",
          "in": "query",
          "name": "q",
          "required": false,
          "type": "string"
        },
        {
          "description": "\nName of a response property sort the result by as per\n[filtering and sorting](../../../meta/filtering#query-sort).\n",
          "in": "query",
          "name": "sort",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "Repository permissions for the repositories a caller has explicit access to.",
          "schema": {
            "$ref": "#/definitions/paginated_repository_permissions"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "account"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "repositories"
      ]
    },
    "parameters": []
  },
  "/user/permissions/teams": {
    "get": {
      "description": "Returns an object for each team the caller is a member of, and their\neffective role  the highest level of privilege the caller has. If a\nuser is a member of multiple groups with distinct roles, only the\nhighest level is returned.\n\nPermissions can be:\n\n* `admin`\n* `collaborator`\n\nExample:\n\n```\n$ curl https://api.bitbucket.org/2.0/user/permissions/teams\n\n{\n  \"pagelen\": 10,\n  \"values\": [\n    {\n      \"permission\": \"admin\",\n      \"type\": \"team_permission\",\n      \"user\": {\n        \"type\": \"user\",\n        \"nickname\": \"evzijst\",\n        \"display_name\": \"Erik van Zijst\",\n        \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\"\n      },\n      \"team\": {\n        \"display_name\": \"Atlassian Bitbucket\",\n        \"uuid\": \"{4cc6108a-a241-4db0-96a5-64347ac04f87}\"\n      }\n    }\n  ],\n  \"page\": 1,\n  \"size\": 1\n}\n```\n\nResults may be further [filtered or sorted](../../../meta/filtering) by\nteam or permission by adding the following query string parameters:\n\n* `q=team.uuid=\"{4cc6108a-a241-4db0-96a5-64347ac04f87}\"` or `q=permission=\"admin\"`\n* `sort=team.display_name`\n\nNote that the query parameter values need to be URL escaped so that `=`\nwould become `%3D`.",
      "parameters": [
        {
          "description": "\nQuery string to narrow down the response as per\n[filtering and sorting](../../../meta/filtering).",
          "in": "query",
          "name": "q",
          "required": false,
          "type": "string"
        },
        {
          "description": "\nName of a response property sort the result by as per\n[filtering and sorting](../../../meta/filtering#query-sort).\n",
          "in": "query",
          "name": "sort",
          "required": false,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "Team permissions for the teams a caller is a member of.",
          "schema": {
            "$ref": "#/definitions/paginated_team_permissions"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "account"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": []
    },
    "parameters": []
  },
  "/users/{username}": {
    "get": {
      "description": "Gets the public information associated with a user account.\n\nIf the user's profile is private, `location`, `website` and\n`created_on` elements are omitted.\n\nNote that the user object returned by this operation is changing significantly, due to privacy changes.\nSee the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-bitbucket-user-objects) for details.",
      "parameters": [
        {
          "description": "The account's UUID, account_id, or username. Note that username has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The user object",
          "examples": {
            "application/json": {
              "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
              "display_name": "Example Username",
              "links": {
                "avatar": {
                  "href": "https://bitbucket.org/account/example-username/avatar/"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/users/example-username"
                }
              },
              "type": "user",
              "username": "example-username",
              "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
            }
          },
          "schema": {
            "$ref": "#/definitions/user"
          }
        },
        "404": {
          "description": "If no user exists for the specified name or UUID, or if the specified account is a team account, not a personal account.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "users"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/users/{username}/followers": {
    "get": {
      "description": "Returns the list of accounts that are following this user.\n\nThis operation has been deprecated due to privacy changes.\nSee the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/) for details.",
      "parameters": [
        {
          "description": "The account's username",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of user objects.",
          "schema": {
            "$ref": "#/definitions/paginated_users"
          }
        },
        "404": {
          "description": "If no account exists for the specified name, or if the specified account is a team account, not a personal account.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": []
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "users"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/users/{username}/following": {
    "get": {
      "description": "Returns the list of accounts this user is following.\n\nThis operation has been deprecated due to privacy changes.\nSee the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/) for details.",
      "parameters": [
        {
          "description": "The user's username",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A paginated list of user objects.",
          "schema": {
            "$ref": "#/definitions/paginated_users"
          }
        },
        "404": {
          "description": "If no user exists for the specified name, or if the specified account is a team account, not a personal account.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "account"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "users"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/users/{username}/hooks": {
    "get": {
      "description": "Returns a paginated list of webhooks installed on this user account.\n\nNote that the username path parameter has been deprecated due to\n[privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).\nUse the account's UUID or account_id instead.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "The paginated list of installed webhooks.",
          "schema": {
            "$ref": "#/definitions/paginated_webhook_subscriptions"
          }
        },
        "403": {
          "description": "If the authenticated user is accessing an account other than their own.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the specified account does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "users",
        "webhooks"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Creates a new webhook on the specified user account.\n\nAccount-level webhooks are fired for events from all repositories\nbelonging to that account.\n\nNote that one can only register webhooks on one's own account, not that\nof others.\n\nAlso, note that the username path parameter has been deprecated due to\n[privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).\nUse the account's UUID or account_id instead.",
      "parameters": [],
      "responses": {
        "201": {
          "description": "The newly installed webhook.",
          "headers": {
            "Location": {
              "description": "The URL of new newly created webhook.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/webhook_subscription"
          }
        },
        "403": {
          "description": "If the authenticated user is accessing an account other than their own.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the specified account does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "users",
        "webhooks"
      ]
    }
  },
  "/users/{username}/hooks/{uid}": {
    "delete": {
      "description": "Deletes the specified webhook subscription from the given user\naccount.\n\nNote that the username path parameter has been deprecated due to\n[privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).\nUse the account's UUID or account_id instead.",
      "parameters": [
        {
          "description": "The installed webhook's id",
          "in": "path",
          "name": "uid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "When the webhook was deleted successfully"
        },
        "403": {
          "description": "If the authenticated user does not have permission to delete the webhook.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the webhook or user does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "users",
        "webhooks"
      ]
    },
    "get": {
      "description": "Returns the webhook with the specified id installed on the given\nuser account.\n\nNote that the username path parameter has been deprecated due to\n[privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).\nUse the account's UUID or account_id instead.",
      "parameters": [
        {
          "description": "The installed webhook's id.",
          "in": "path",
          "name": "uid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The webhook subscription object.",
          "schema": {
            "$ref": "#/definitions/webhook_subscription"
          }
        },
        "404": {
          "description": "If the webhook or user does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "users",
        "webhooks"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      },
      {
        "in": "path",
        "name": "uid",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Updates the specified webhook subscription.\n\nThe following properties can be mutated:\n\n* `description`\n* `url`\n* `active`\n* `events`\n\nNote that the username path parameter has been deprecated due to\n[privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).\nUse the account's UUID or account_id instead.",
      "parameters": [
        {
          "description": "The installed webhook's id",
          "in": "path",
          "name": "uid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The webhook subscription object.",
          "schema": {
            "$ref": "#/definitions/webhook_subscription"
          }
        },
        "403": {
          "description": "If the authenticated user does not have permission to update the webhook.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "If the webhook or user does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "webhook"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "users",
        "webhooks"
      ]
    }
  },
  "/users/{username}/members": {
    "get": {
      "description": "Returns all members of the specified team. Any member of any of the\nteam's groups is considered a member of the team. This includes users\nin groups that may not actually have access to any of the team's\nrepositories.\n\nThis operation has been deprecated due to privacy changes.\nSee the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/)\nfor details.",
      "parameters": [],
      "responses": {
        "200": {
          "description": "All members",
          "examples": {
            "application/json": {
              "account_id": "123456:daffbc08-1a80-4bd0-98bf-7997de0a3d10",
              "account_status": "active",
              "display_name": "Example Username",
              "links": {
                "avatar": {
                  "href": "https://bitbucket.org/account/example-username/avatar/"
                },
                "html": {
                  "href": "https://bitbucket.org/example-username/"
                },
                "self": {
                  "href": "https://api.bitbucket.org/2.0/users/example-username"
                }
              },
              "nickname": "example-username",
              "type": "user",
              "username": "example-username",
              "uuid": "{58021780-82b6-4517-b153-0ae73ce3e4b4}"
            }
          },
          "schema": {
            "$ref": "#/definitions/user"
          }
        },
        "404": {
          "description": "When the team does not exist, or multiple teams with the same name exist that differ only in casing and the URL did not match the exact casing of a particular one.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "account"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "teams"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/users/{username}/pipelines_config/variables/": {
    "get": {
      "description": "Find user level variables.",
      "operationId": "getPipelineVariablesForUser",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The found user level variables.",
          "schema": {
            "$ref": "#/definitions/paginated_pipeline_variables"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "post": {
      "description": "Create a user level variable.",
      "operationId": "createPipelineVariableForUser",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The variable to create.",
          "in": "body",
          "name": "_body",
          "required": false,
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The created variable.",
          "headers": {
            "Location": {
              "description": "The URL of the newly created pipeline variable.",
              "type": "string"
            }
          },
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        },
        "404": {
          "description": "The account does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "409": {
          "description": "A variable with the provided key already exists.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/users/{username}/pipelines_config/variables/{variable_uuid}": {
    "delete": {
      "description": "Delete an account level variable.",
      "operationId": "deletePipelineVariableForUser",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the variable to delete.",
          "in": "path",
          "name": "variable_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "The variable was deleted"
        },
        "404": {
          "description": "The account or the variable with the provided UUID does not exist.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "get": {
      "description": "Retrieve a user level variable.",
      "operationId": "getPipelineVariableForUser",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the variable to retrieve.",
          "in": "path",
          "name": "variable_uuid",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The variable.",
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        },
        "404": {
          "description": "The account or variable with the given UUID was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    },
    "put": {
      "description": "Update a user level variable.",
      "operationId": "updatePipelineVariableForUser",
      "parameters": [
        {
          "description": "The account.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The UUID of the variable.",
          "in": "path",
          "name": "variable_uuid",
          "required": true,
          "type": "string"
        },
        {
          "description": "The updated variable.",
          "in": "body",
          "name": "_body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The variable was updated.",
          "schema": {
            "$ref": "#/definitions/pipeline_variable"
          }
        },
        "404": {
          "description": "The account or the variable was not found.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "tags": [
        "pipelines"
      ]
    }
  },
  "/users/{username}/properties/{app_key}/{property_name}": {
    "delete": {
      "description": "Delete an application property value stored against a user.",
      "operationId": "deleteUserHostedPropertyValue",
      "parameters": [
        {
          "description": "The user.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The key of the Connect app.",
          "in": "path",
          "name": "app_key",
          "required": true,
          "type": "string"
        },
        {
          "description": "The name of the property.",
          "in": "path",
          "name": "property_name",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "An empty response."
        }
      },
      "tags": [
        "properties"
      ]
    },
    "get": {
      "description": "Retrieve an application property value stored against a user.",
      "operationId": "retrieveUserHostedPropertyValue",
      "parameters": [
        {
          "description": "The user.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The key of the Connect app.",
          "in": "path",
          "name": "app_key",
          "required": true,
          "type": "string"
        },
        {
          "description": "The name of the property.",
          "in": "path",
          "name": "property_name",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The value of the property."
        }
      },
      "tags": [
        "properties"
      ]
    },
    "put": {
      "description": "Update an application property value stored against a user.",
      "operationId": "updateUserHostedPropertyValue",
      "parameters": [
        {
          "description": "The user.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The key of the Connect app.",
          "in": "path",
          "name": "app_key",
          "required": true,
          "type": "string"
        },
        {
          "description": "The name of the property.",
          "in": "path",
          "name": "property_name",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "An empty response."
        }
      },
      "tags": [
        "properties"
      ]
    }
  },
  "/users/{username}/repositories": {
    "get": {
      "description": "All repositories owned by a user/team. This includes private\nrepositories, but filtered down to the ones that the calling user has\naccess to.",
      "parameters": [],
      "responses": {
        "default": {
          "description": "Unexpected error.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "repository"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "users",
        "teams"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ]
  },
  "/users/{username}/search/code": {
    "get": {
      "operationId": "searchAccount",
      "parameters": [
        {
          "description": "The account to search in; either the username or the UUID in curly braces",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The search query",
          "in": "query",
          "name": "search_query",
          "required": true,
          "type": "string"
        },
        {
          "default": 1,
          "description": "Which page of the search results to retrieve",
          "format": "int32",
          "in": "query",
          "name": "page",
          "required": false,
          "type": "integer"
        },
        {
          "default": 10,
          "description": "How many search results to retrieve per page",
          "format": "int32",
          "in": "query",
          "name": "pagelen",
          "required": false,
          "type": "integer"
        }
      ],
      "produces": [
        "application/json"
      ],
      "responses": {
        "200": {
          "description": "Successful search",
          "schema": {
            "$ref": "#/definitions/search_result_page"
          }
        },
        "400": {
          "description": "If the search request was invalid due to one of the following reasons:\n* the specified type of target account doesn't match the actual account type;\n* malformed pagination properties;\n* missing or malformed search query, in the latter case an error key will be returned in `error.data.key` property.",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "404": {
          "description": "Search is not enabled for the requested user, navigate to [https://bitbucket.org/search](https://bitbucket.org/search) to turn it on",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "429": {
          "description": "Too many requests, try again later",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "summary": "Search for code in the repositories of the specified user",
      "tags": [
        "search"
      ]
    }
  },
  "/users/{username}/ssh-keys": {
    "get": {
      "description": "Returns a paginated list of the user's SSH public keys.\n\nExample:\n\n```\n$ curl https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys\n{\n    \"page\": 1,\n    \"pagelen\": 10,\n    \"size\": 1,\n    \"values\": [\n        {\n            \"comment\": \"user@myhost\",\n            \"created_on\": \"2018-03-14T13:17:05.196003+00:00\",\n            \"key\": \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY\",\n            \"label\": \"\",\n            \"last_used\": \"2018-03-20T13:18:05.196003+00:00\",\n            \"links\": {\n                \"self\": {\n                    \"href\": \"https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/b15b6026-9c02-4626-b4ad-b905f99f763a\"\n                }\n            },\n            \"owner\": {\n                \"display_name\": \"Mark Adams\",\n                \"links\": {\n                    \"avatar\": {\n                        \"href\": \"https://bitbucket.org/account/markadams-atl/avatar/32/\"\n                    },\n                    \"html\": {\n                        \"href\": \"https://bitbucket.org/markadams-atl/\"\n                    },\n                    \"self\": {\n                        \"href\": \"https://api.bitbucket.org/2.0/users/markadams-atl\"\n                    }\n                },\n                \"type\": \"user\",\n                \"username\": \"markadams-atl\",\n                \"nickname\": \"markadams-atl\",\n                \"uuid\": \"{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}\"\n            },\n            \"type\": \"ssh_key\",\n            \"uuid\": \"{b15b6026-9c02-4626-b4ad-b905f99f763a}\"\n        }\n    ]\n}\n```",
      "parameters": [
        {
          "description": "The account's UUID, account_id, or username. Note that username has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "A list of the SSH keys associated with the account.",
          "schema": {
            "$ref": "#/definitions/paginated_ssh_user_keys"
          }
        },
        "403": {
          "description": "If the specified user's keys are not accessible to the current user"
        },
        "404": {
          "description": "If the specified user does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "account"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "ssh"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ],
    "post": {
      "description": "Adds a new SSH public key to the specified user account and returns the resulting key.\n\nExample:\n```\n$ curl -X POST -H \"Content-Type: application/json\" -d '{\"key\": \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY user@myhost\"}' https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys\n\n{\n    \"comment\": \"user@myhost\",\n    \"created_on\": \"2018-03-14T13:17:05.196003+00:00\",\n    \"key\": \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY\",\n    \"label\": \"\",\n    \"last_used\": \"2018-03-20T13:18:05.196003+00:00\",\n    \"links\": {\n        \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/b15b6026-9c02-4626-b4ad-b905f99f763a\"\n        }\n    },\n    \"owner\": {\n        \"display_name\": \"Mark Adams\",\n        \"links\": {\n            \"avatar\": {\n                \"href\": \"https://bitbucket.org/account/markadams-atl/avatar/32/\"\n            },\n            \"html\": {\n                \"href\": \"https://bitbucket.org/markadams-atl/\"\n            },\n            \"self\": {\n                \"href\": \"https://api.bitbucket.org/2.0/users/markadams-atl\"\n            }\n        },\n        \"type\": \"user\",\n        \"username\": \"markadams-atl\",\n        \"nickname\": \"markadams-atl\",\n        \"uuid\": \"{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}\"\n    },\n    \"type\": \"ssh_key\",\n    \"uuid\": \"{b15b6026-9c02-4626-b4ad-b905f99f763a}\"\n}\n```",
      "parameters": [
        {
          "description": "The account's UUID, account_id, or username. Note that username has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The new SSH key object. Note that the username property has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).",
          "in": "body",
          "name": "_body",
          "required": false,
          "schema": {
            "$ref": "#/definitions/ssh_account_key"
          }
        }
      ],
      "responses": {
        "201": {
          "description": "The newly created SSH key.",
          "schema": {
            "$ref": "#/definitions/ssh_account_key"
          }
        },
        "400": {
          "description": "If the submitted key or related value is invalid",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If the current user does not have permission to add a key for the specified user"
        },
        "404": {
          "description": "If the specified user does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "account:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "ssh"
      ]
    }
  },
  "/users/{username}/ssh-keys/": {
    "delete": {
      "description": "Deletes a specific SSH public key from a user's account\n\nExample:\n```\n$ curl -X DELETE https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/{b15b6026-9c02-4626-b4ad-b905f99f763a}\n```",
      "parameters": [
        {
          "description": "The account's username or UUID.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The SSH key's UUID value.",
          "in": "path",
          "name": "key_id",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "204": {
          "description": "The key has been deleted"
        },
        "400": {
          "description": "If the submitted key or related value is invalid",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If the current user does not have permission to add a key for the specified user"
        },
        "404": {
          "description": "If the specified user does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "account:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "ssh"
      ]
    },
    "get": {
      "description": "Returns a specific SSH public key belonging to a user.\n\nExample:\n```\n$ curl https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/{fbe4bbab-f6f7-4dde-956b-5c58323c54b3}\n\n{\n    \"comment\": \"user@myhost\",\n    \"created_on\": \"2018-03-14T13:17:05.196003+00:00\",\n    \"key\": \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY\",\n    \"label\": \"\",\n    \"last_used\": \"2018-03-20T13:18:05.196003+00:00\",\n    \"links\": {\n        \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/b15b6026-9c02-4626-b4ad-b905f99f763a\"\n        }\n    },\n    \"owner\": {\n        \"display_name\": \"Mark Adams\",\n        \"links\": {\n            \"avatar\": {\n                \"href\": \"https://bitbucket.org/account/markadams-atl/avatar/32/\"\n            },\n            \"html\": {\n                \"href\": \"https://bitbucket.org/markadams-atl/\"\n            },\n            \"self\": {\n                \"href\": \"https://api.bitbucket.org/2.0/users/markadams-atl\"\n            }\n        },\n        \"type\": \"user\",\n        \"username\": \"markadams-atl\",\n        \"nickname\": \"markadams-atl\",\n        \"uuid\": \"{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}\"\n    },\n    \"type\": \"ssh_key\",\n    \"uuid\": \"{b15b6026-9c02-4626-b4ad-b905f99f763a}\"\n}\n```",
      "parameters": [
        {
          "description": "The account's username or UUID.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The SSH key's UUID value.",
          "in": "path",
          "name": "key_id",
          "required": true,
          "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "The specific SSH key matching the user and UUID",
          "schema": {
            "$ref": "#/definitions/ssh_account_key"
          }
        },
        "403": {
          "description": "If the specified user or key is not accessible to the current user"
        },
        "404": {
          "description": "If the specified user or key does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "account"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "ssh"
      ]
    },
    "parameters": [
      {
        "description": "This can either be the username or the UUID of the account,\nsurrounded by curly-braces, for example: `{account UUID}`. An account\nis either a team or user.\n",
        "in": "path",
        "name": "username",
        "required": true,
        "type": "string"
      }
    ],
    "put": {
      "description": "Updates a specific SSH public key on a user's account\n\nNote: Only the 'comment' field can be updated using this API. To modify the key or comment values, you must delete and add the key again.\n\nExample:\n```\n$ curl -X PUT -H \"Content-Type: application/json\" -d '{\"label\": \"Work key\"}' https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/{b15b6026-9c02-4626-b4ad-b905f99f763a}\n\n{\n    \"comment\": \"\",\n    \"created_on\": \"2018-03-14T13:17:05.196003+00:00\",\n    \"key\": \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY\",\n    \"label\": \"Work key\",\n    \"last_used\": \"2018-03-20T13:18:05.196003+00:00\",\n    \"links\": {\n        \"self\": {\n            \"href\": \"https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/b15b6026-9c02-4626-b4ad-b905f99f763a\"\n        }\n    },\n    \"owner\": {\n        \"display_name\": \"Mark Adams\",\n        \"links\": {\n            \"avatar\": {\n                \"href\": \"https://bitbucket.org/account/markadams-atl/avatar/32/\"\n            },\n            \"html\": {\n                \"href\": \"https://bitbucket.org/markadams-atl/\"\n            },\n            \"self\": {\n                \"href\": \"https://api.bitbucket.org/2.0/users/markadams-atl\"\n            }\n        },\n        \"type\": \"user\",\n        \"username\": \"markadams-atl\",\n        \"nickname\": \"markadams-atl\",\n        \"uuid\": \"{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}\"\n    },\n    \"type\": \"ssh_key\",\n    \"uuid\": \"{b15b6026-9c02-4626-b4ad-b905f99f763a}\"\n}\n```",
      "parameters": [
        {
          "description": "The account's username or UUID.",
          "in": "path",
          "name": "username",
          "required": true,
          "type": "string"
        },
        {
          "description": "The SSH key's UUID value.",
          "in": "path",
          "name": "key_id",
          "required": true,
          "type": "string"
        },
        {
          "description": "The updated SSH key object",
          "in": "body",
          "name": "_body",
          "required": false,
          "schema": {
            "$ref": "#/definitions/ssh_account_key"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The newly updated SSH key.",
          "schema": {
            "$ref": "#/definitions/ssh_account_key"
          }
        },
        "400": {
          "description": "If the submitted key or related value is invalid",
          "schema": {
            "$ref": "#/definitions/error"
          }
        },
        "403": {
          "description": "If the current user does not have permission to add a key for the specified user"
        },
        "404": {
          "description": "If the specified user does not exist",
          "schema": {
            "$ref": "#/definitions/error"
          }
        }
      },
      "security": [
        {
          "oauth2": [
            "account:write"
          ]
        },
        {
          "basic": []
        },
        {
          "api_key": []
        }
      ],
      "tags": [
        "ssh"
      ]
    }
  }
}
